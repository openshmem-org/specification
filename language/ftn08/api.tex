As the \Fortran[bind(C)] language bindings are implemented over the \openshmem
\Cstd language bindings, there are no semantic or functional differences in the
\Fortran[bind(C)] language binding interfaces. The following sections tabulates
the argument and standard type definition for the \Fortran[bind(C)] language
bindings with the corresponding \Cstd language bindings for semantic reference.
Refer \openshmem specification for argument definition, API description, and
explanation on the return values.
\\
\\
\\
\subsubsection{Library Setup, Exit, and Query Routines}
\label{subsubsec:ftn_setup}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
SUBROUTINE shmem\_init()

\textit{Argument Mapping}:
None.

\textit{Return}:
None.
 &
void shmem\_init(void);
\tabularnewline \hline
%%
FUNCTION shmem\_my\_pe()

\textit{Argument Mapping}:
None.

\textit{Return}:
INTEGER(C\_INT) :: pe\_index
&
int shmem\_my\_pe(void);
\tabularnewline \hline
%%
FUNCTION shmem\_n\_pes()

\textit{Argument Mapping}:
None.

\textit{Return}:
INTEGER(C\_INT) :: num\_pes
&
int shmem\_n\_pes(void);
\tabularnewline \hline
%%
SUBROUTINE shmem\_finalize()

\textit{Argument Mapping}:
None.

\textit{Return}:
None.
&
void shmem\_finalize(void);
\tabularnewline \hline
%%
SUBROUTINE shmem\_global\_exit(status)

\textit{Argument Mapping}:

INTEGER(C\_INT), INTENT(IN) :: status

\textit{Return}:
None.
&
void shmem\_global\_exit(int status);
\tabularnewline \hline
%%
\end{longtable}

\subsubsection{Thread Support}
\label{subsubsec:ftn_thread}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
FUNCTION shmem\_init\_thread(requested, actual)

\textit{Argument Mapping}:

INTEGER(C\_INT), INTENT(IN) :: requested

TYPE(INTEGER), INTENT(OUT) :: actual

\textit{Return}:

INTEGER(C\_INT) :: error\_code
&
int shmem\_init\_thread(int requested,

int *actual);
\tabularnewline \hline
%%
SUBROUTINE shmem\_query\_thread(provided)

\textit{Argument Mapping}:

TYPE(INTEGER), INTENT(OUT) :: provided

\textit{Return}:
None.
&
void shmem\_query\_thread(int *provided);
\tabularnewline \hline
%%
\end{longtable}


\subsubsection{Memory Management Routines}
\label{subsubsec:ftn_mem_manage}

\subsubsection{Communication Management Routines}
\label{subsubsec:ftn_comm_manage}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
FUNCTION shmem\_ctx\_create(options, ctx)

\textit{Argument Mapping}:

INTEGER(C\_INT), INTENT(IN) :: options

TYPE(shmem\_ctx\_t), INTENT(OUT) :: ctx

\textit{Return}:

INTEGER(C\_INT) :: error\_code
&
int shmem\_ctx\_create(long options,

shmem\_ctx\_t *ctx);
\tabularnewline \hline
%%
SUBROUTINE shmem\_ctx\_destroy(ctx)

\textit{Argument Mapping}:

TYPE(shmem\_ctx\_t), INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_destroy(shmem\_ctx\_t ctx);
\tabularnewline \hline
%%
\end{longtable}


\subsubsection{Remote Memory Access Routines}
\label{subsubsec:ftn_rma}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
SUBROUTINE shmem\_putmem(dest, src, nbytes, pe, ctx)

\textit{Argument Mapping}:

TYPE(*),DIMENSION(*),INTENT(OUT) :: dest

TYPE(*),DIMENSION(*),INTENT(IN) :: src

INTEGER(C\_SIZE\_T), INTENT(IN) :: nbytes

INTEGER(C\_INT), INTENT(IN) :: pe

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_putmem(shmem\_ctx\_t *ctx, void *dest, const void *src, size\_t nelems, int pe);
\tabularnewline \hline
%%
SUBROUTINE shmem\_getmem(dest, src, nbytes, pe, ctx)

\textit{Argument Mapping}:

TYPE(*),DIMENSION(*),INTENT(OUT) :: dest

TYPE(*),DIMENSION(*),INTENT(IN) :: src

INTEGER(C\_SIZE\_T), INTENT(IN) :: nbytes

INTEGER(C\_INT), INTENT(IN) :: pe

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_getmem(shmem\_ctx\_t *ctx, void *dest, const void *src, size\_t nelems, int pe);
\tabularnewline \hline
%%
\end{longtable}


\subsubsection{Non-blocking Remote Memory Access Routines}
\label{subsubsec:ftn_rma_nbi}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
SUBROUTINE shmem\_putmem\_nbi(dest, src, nbytes, pe, ctx)

\textit{Argument Mapping}:

TYPE(*),DIMENSION(*),INTENT(OUT) :: dest

TYPE(*),DIMENSION(*),INTENT(IN) :: src

INTEGER(C\_SIZE\_T), INTENT(IN) :: nbytes

INTEGER(C\_INT), INTENT(IN) :: pe

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_putmem\_nbi(shmem\_ctx\_t *ctx, void *dest, const void *src, size\_t nelems, int pe);
\tabularnewline \hline
%%
SUBROUTINE shmem\_getmem\_nbi(dest, src, nbytes, pe, ctx)

\textit{Argument Mapping}:

TYPE(*),DIMENSION(*),INTENT(OUT) :: dest

TYPE(*),DIMENSION(*),INTENT(IN) :: src

INTEGER(C\_SIZE\_T), INTENT(IN) :: nbytes

INTEGER(C\_INT), INTENT(IN) :: pe

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_getmem\_nbi(shmem\_ctx\_t *ctx, void *dest, const void *src, size\_t nelems, int pe);
\tabularnewline \hline
%%
\end{longtable}


\subsubsection{Atomic Memory Operations}
\label{subsubsec:ftn_amo}

\subsubsection{Collective Routines}
\label{subsubsec:ftn_coll}

\subsubsection{Point-To-Point Synchronization Routines}
\label{subsubsec:ftn_ptp_sync}

\subsubsection{Memory Ordering Routines}
\label{subsubsec:ftn_mem_order}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
SUBROUTINE shmem\_quiet(ctx)

\textit{Argument Mapping}:

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_quiet(shmem\_ctx\_t *ctx);
\tabularnewline \hline
%%
SUBROUTINE shmem\_fence(ctx)

\textit{Argument Mapping}:

TYPE(shmem\_ctx\_t), OPTIONAL, INTENT(IN) :: ctx

\textit{Return}:
None.
&
void shmem\_ctx\_fence(shmem\_ctx\_t *ctx);
\tabularnewline \hline
%%
\end{longtable}

\subsubsection{Distributed Locking Routines}
\label{subsubsec:ftn_locks}

\begin{longtable}{|p{0.58\textwidth}|p{0.40\textwidth}|}
\hline
\textbf{\Fortran[bind(C)] Language Binding Interface} &
\textbf{\Cstd Language Binding Interface}
\tabularnewline \hline
\endhead
%%
SUBROUTINE shmem\_clear\_lock(lock)

\textit{Argument Mapping}:

INTEGER(C\_LONG),INTENT(IN) :: lock

\textit{Return}:
None.
&
void shmem\_clear\_lock(long *lock);
\tabularnewline \hline
%%
SUBROUTINE shmem\_set\_lock(lock)

\textit{Argument Mapping}:

INTEGER(C\_LONG),INTENT(IN) :: lock

\textit{Return}:
None.
&
void shmem\_set\_lock(long *lock);
\tabularnewline \hline
%%
FUNCTION shmem\_test\_lock(lock)

\textit{Argument Mapping}:

INTEGER(C\_LONG),INTENT(IN) :: ctx

\textit{Return}:

INTEGER(C\_INT)::status
&
int shmem\_test\_lock(long *lock);
\tabularnewline \hline
%%
\end{longtable}

