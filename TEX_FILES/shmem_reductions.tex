\bAPI{SHMEM\_REDUCTIONS}{Performs a logical operations across a set of \ac{PE}s.}

\synC %Synopisis for C API

void shmem_int_and_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_and_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_and_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_and_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_double_max_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_max_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_max_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_max_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_max_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_max_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_max_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_double_min_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_min_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_min_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_min_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_min_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_min_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_min_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_complexd_sum_to_all(double complex *target, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_sum_to_all(float complex *target, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_sum_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_sum_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_sum_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_sum_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride,int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_sum_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_sum_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_sum_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_complexd_prod_to_all(double complex *target, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_prod_to_all(float complex *target, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_prod_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_prod_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_prod_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_prod_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_prod_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_prod_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_prod_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_int_or_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_or_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_or_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_or_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_int_xor_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_xor_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_xor_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_xor_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync); %*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_AND_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_AND_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP4_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_OR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_OR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)	
CALL SHMEM_COMP4_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync) %*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT  

% Arguments table. If no arguments you can use \argRow{None}{}{} 
\desB{   
       \argRow{IN}{target}{A symmetric array, of length \VAR{nreduce} elements, to receive the result of the reduction operations. The data type of \target{} varies with the version of the reduction routine being called. When calling from \CorCpp, refer to the SYNOPSIS section for data type information.}
	\argRow{IN}{source}{ A symmetric array, of length \VAR{nreduce} elements, that contains one element for each separate reduction operation.	The \source{} argument must have the same data type as \target.}
        \argRow{IN}{\VAR{nreduce}}{The number of elements in the \target{} and \source{} arrays. \VAR{nreduce} must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_start}{The lowest virtual \ac{PE} number of the \activeset{} of \ac{PE}s. \VAR{PE\_start} must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{logPE\_stride}{The log (base 2) of the stride between consecutive virtual \ac{PE} numbers in the \activeset. logPE\_stride must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_size}{The number of \ac{PE}s in the \activeset. PE\_size must	be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{pWrk}{A symmetric work array. The pWrk argument must have the same data type as \target. In \CorCpp, this contains max(\VAR{nreduce}/2 + 1, \CONST{\_SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements. In \Fortran, this contains max(\VAR{nreduce}/2 + 1, \CONST{SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements.}
        \argRow{IN}{pSync}{A symmetric work array. In \CorCpp, \VAR{pSync} must be of type long and size \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}. In \Fortran, \VAR{pSync} must be of type integer and size \CONST{SHMEM\_REDUCE\_SYNC\_SIZE}. If you are using \Fortran, it must be a default integer value. Every element of this array must be initialized with the value \CONST{\_SHMEM\_SYNC\_VALUE} (in \CorCpp) or \CONST{SHMEM\_SYNC\_VALUE} (in \Fortran) before any of the \ac{PE}s in the \activeset{} enter the reduction routine.}
 }
 %API description
 {  
 \openshmem reduction	routines compute one or more
 reductions across symmetric arrays on multiple virtual \ac{PE}s. A
 reduction performs an associative binary operation across a set of
 values.	 
 
  The \VAR{nreduce} argument determines the number of separate reductions to
 perform. The \source{} array on all \ac{PE}s in the \activeset{} provides one
 element for each reduction. The results of the reductions are placed
 in the \target{} array on all \ac{PE}s in the \activeset. The \activeset{} is
 defined by the \VAR{PE\_start}, \VAR{logPE\_stride}, \VAR{PE\_size} triplet.

 The \source{} and \target{} arrays may be the same array, but they may not be
 overlapping arrays.

 As with all \openshmem{} collective routines, each of these routines assumes
 that only \ac{PE}s in the \activeset{} call the routine. If a \ac{PE} not in the
 \activeset{} calls a \openshmem collective routine, undefined behavior
 results.

 The values of arguments \VAR{nreduce}, \VAR{PE\_start}, \VAR{logPE\_stride}, and \VAR{PE\_size}
 must be equal on all \ac{PE}s in the \activeset. The same \target{} and \source{}
 arrays, and the same \VAR{pWrk} and \VAR{pSync} work arrays, must be passed to all
 \ac{PE}s in the \activeset.

 Before any \ac{PE}	calls a reduction routine, you must ensure that the
 following conditions exist (synchronization via a \OPR{barrier} or some other
 method is often needed to ensure this): The \VAR{pWrk} and \VAR{pSync} arrays on
 all \ac{PE}s in the \activeset{} are not still in use from a prior call to a
 collective \openshmem{} routine. The \target{} array on all \ac{PE}s in the \activeset{} 
 is ready to accept the results of the \OPR{reduction}.

 Upon return from a reduction routine, the following are true for the
 local \ac{PE}: The \target{} array is updated. The values in the \VAR{pSync} array
 are restored to the original values.
}
{
\hfill \\
 \desTBC{ When calling from \Fortran, the \target{} date types are as follows:}
                {Routine}{Data Type}{
		  \cRow{shmem\_int8\_and\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_\_int4\_and\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_comp8\_max\_to\_all}{Complex, with an element size	equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_max\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_max\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_max\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real16\_max\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int4\_min\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_min\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_min\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_min\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_min\_to\_all}{Real,with an element size of 16 bytes.}
		  \cRow{shmem\_comp4\_sum\_to\_all}{COMPLEX(KIND=4).}
		  \cRow{shmem\_comp8\_sum\_to\_all}{Complex. If you are using \Fortran, it must be a default complex value.}
		  \cRow{shmem\_int4\_sum\_to\_all}{INTEGER(KIND=4).}
		  \cRow{shmem\_int8\_sum\_to\_all}{Integer. If you are using \Fortran, it must be a default integer value.}
		  \cRow{shmem\_real4\_sum\_to\_all}{REAL(KIND=4).}
		  \cRow{shmem\_real8\_sum\_to\_all}{	 Real. If you are using \Fortran, it must be a default real value.}
		  \cRow{shmem\_real16\_sum\_to\_all}{	 Real. If you are using \Fortran, it must be a default real value.}
		  \cRow{shmem\_comp4\_prod\_to\_all	}{ Complex, with an element size	equal to two 4-byte real values. }		  \cRow{shmem\_comp8\_prod\_to\_all	}{ Complex, with an element size	equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_prod\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_prod\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_prod\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_prod\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_prod\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int8\_or\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_or\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_comp8\_xor\_to\_all}{Complex, with an element size equal to two 8-byte real values.}
		  \cRow{shmem\_comp4\_xor\_to\_all}{Complex, with an element size equal to two 4-byte real values.}
		  \cRow{shmem\_int8\_xor\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_xor\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_xor\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_xor\_to\_all}{Real, with an element size of 4 bytes.}
		  }
}%end of DesB
 %Return Values     
\desR{None.}

% Notes. If there are no notes, this field can be left empty.
\notesB{  
 All \openshmem{} reduction routines reset the values in \VAR{pSync} before they
 return, so a particular \VAR{pSync} buffer need only be initialized the first
 time it is used.

 You must ensure that the \VAR{pSync} array is not being updated on any \ac{PE} in
 the \activeset{} while any of the \ac{PE}s participate in processing of a
 \openshmem{} reduction routine. Be careful to avoid the following situations:
 If the \VAR{pSync} array is initialized at run time, some type of synchronization is needed to
 ensure that all \ac{PE}s in the working set have initialized \VAR{pSync} before any of 
 them enter an \openshmem routine called
 with the \VAR{pSync} synchronization array. A \VAR{pSync} or \VAR{pWrk} array can be
 reused in a subsequent reduction routine call only if none of the \ac{PE}s
 in the \activeset{} are still processing a prior reduction routine call
 that used the same \VAR{pSync} or \VAR{pWrk} arrays. In general, this can be
 assured only by doing some type of synchronization. However, in the
 special case of reduction routines being called with the same \activeset, 
 you can allocate two \VAR{pSync} and \VAR{pWrk} arrays and alternate between
 them on successive calls.
}

%Example
\exampleB{
%For each example, you can enter it as an item.
                  \exampleITEMF
                  { This \Fortran{} example statically initializes the \VAR{pSync} array and finds the logical \OPR{AND} of the integer variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_and_example.f90}
                  {}
                   \exampleITEMF
	          {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{maximum} value of real variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_max_example.f90}
                  {}
                  \exampleITEMF
                  { This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{minimum} value of real variable \VAR{FOO} across all the even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_min_example.f90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{sum} of the real variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_sum_example.f90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{product} of the real variable \VAR{FOO} across all the even \ac{PE}s.}
                  {./EXAMPLES/shmem_prod_example.f90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the logical \OPR{OR} of the integer variable \VAR{FOO} across all even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_or_example.f90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and computes the exclusive \OPR{XOR} of variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_xor_example.f90}
                   {} 
                 }  	
\eAPI 



