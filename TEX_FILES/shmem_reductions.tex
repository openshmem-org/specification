\bAPI{SHMEM\_REDUCTIONS}{Performs arithmetic and logical operations across a set of \ac{PE}s.}

\textbf{AND} \newline
Performs a bitwise AND function across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_int_and_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_and_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_and_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_and_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
void shmem_int_and_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_AND_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_AND_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
%*\synFE  %DO NOT DELETE. THIS LINE IS NOT A COMMENT 

\bigskip
\textbf{MAX} \newline
Performs a maximum function reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_double_max_to_all(double *dest, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_max_to_all(float *dest, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_max_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_max_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_max_to_all(long double *dest, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_max_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_max_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_MAX_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MAX_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MAX_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MAX_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MAX_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
%*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\bigskip
\textbf{MIN} \newline
Performs a minimum function reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_double_min_to_all(double *dest, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_min_to_all(float *dest, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_min_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_min_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_min_to_all(long double *dest, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_min_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_min_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT
\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_MIN_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MIN_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MIN_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MIN_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MIN_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
%*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\bigskip
\textbf{SUM} \newline
Performs a sum reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_complexd_sum_to_all(double complex *dest, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_sum_to_all(float complex *dest, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_sum_to_all(double *dest, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_sum_to_all(float *dest, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_sum_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_sum_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride,int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_sum_to_all(long double *dest, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_sum_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_sum_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT
\synF %Synopsis for FORTRAN API

CALL SHMEM_COMP4_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_SUM_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
%*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\bigskip
\textbf{PROD} \newline
Performs a product reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_complexd_prod_to_all(double complex *dest, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_prod_to_all(float complex *dest, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_prod_to_all(double *dest, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_prod_to_all(float *dest, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_prod_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_prod_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_prod_to_all(long double *dest, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_prod_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_prod_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT
\synF %Synopsis for FORTRAN API

CALL SHMEM_COMP4_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_PROD_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
%*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\bigskip
\textbf{OR} \newline
Performs  a  bitwise  OR  function reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_int_or_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_or_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_or_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_or_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT
\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_OR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_OR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)	
%*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\bigskip
\textbf{XOR}\newline
Performs  a  bitwise  EXCLUSIVE OR reduction across a set of processing elements (\ac{PE}s).\newline
\synC %Synopisis for C API

void shmem_int_xor_to_all(int *dest, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_xor_to_all(long *dest, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_xor_to_all(long long *dest, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_xor_to_all(short *dest, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync); %*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT
\synF %Synopsis for FORTRAN API

CALL SHMEM_INT4_XOR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_XOR_TO_ALL(dest, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync) %*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT  

% Arguments table. If no arguments you can use \argRow{None}{}{} 
\desB{   
       \argRow{IN}{dest}{A symmetric array, of length \VAR{nreduce} elements, to receive the result of the reduction routines.  The data type of \dest{} varies with the version of the reduction routine being called.  When calling from \CorCpp, refer to the SYNOPSIS section for data type information.}
	\argRow{IN}{source}{ A symmetric array, of length \VAR{nreduce} elements, that contains one element for each separate reduction routine.  The \source{} argument must have the same data type as \dest.}
        \argRow{IN}{\VAR{nreduce}}{The number of elements in the \dest{} and \source{} arrays.  \VAR{nreduce} must be of type integer.  If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_start}{The lowest \ac{PE} number of the \activeset{} of \ac{PE}s.  \VAR{PE\_start} must be of type integer.  If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{logPE\_stride}{The log (base 2) of the stride between consecutive \ac{PE} numbers in the \activeset.  \VAR{logPE\_stride} must be of type integer.  If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_size}{The number of \ac{PE}s in the \activeset.  \VAR{PE\_size} must be of type integer.  If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{pWrk}{A symmetric work array. The \VAR{pWrk} argument must have the same data type as \dest. In \CorCpp, this contains max(\VAR{nreduce}/2 + 1, \CONST{\_SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements. In \Fortran, this contains max(\VAR{nreduce}/2 + 1, \CONST{SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements.}
        \argRow{IN}{pSync}{A symmetric work array. In \CorCpp, \VAR{pSync} must be of type long and size \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}. In \Fortran, \VAR{pSync} must be of type integer and size \CONST{SHMEM\_REDUCE\_SYNC\_SIZE}.  If you are using \Fortran, it must be a default integer value. Every element of this array must be initialized with the value \CONST{\_SHMEM\_SYNC\_VALUE} (in \CorCpp) or \CONST{SHMEM\_SYNC\_VALUE} (in \Fortran) before any of the \ac{PE}s in the \activeset{} enter the reduction routine.}
 }
 %API description
 {  
 \openshmem reduction routines compute one or more
 reductions across symmetric arrays on multiple \acp{PE}.  A
 reduction performs an associative binary routine across a set of
 values.	 
 
  The \VAR{nreduce} argument determines the number of separate reductions to
 perform.  The \source{} array on all \ac{PE}s in the \activeset{} provides one
 element for each reduction.  The results of the reductions are placed
 in the \dest{} array on all \ac{PE}s in the \activeset.  The \activeset{} is
 defined by the \VAR{PE\_start}, \VAR{logPE\_stride}, \VAR{PE\_size} triplet.

 The \source{} and \dest{} arrays may be the same array, but they may not be
 overlapping arrays.

 As with all \openshmem{} collective routines, each of these routines assumes
 that only \ac{PE}s in the \activeset{} call the routine.  If a \ac{PE} not in the
 \activeset{} calls an \openshmem collective routine, undefined behavior
 results.

The values of arguments \VAR{nreduce}, \VAR{PE\_start}, \VAR{logPE\_stride}, and \VAR{PE\_size} must be equal on all \ac{PE}s in the \activeset. The same \dest{} and \source{} arrays, and the same \VAR{pWrk} and \VAR{pSync} work arrays, must be passed to all \ac{PE}s in the \activeset.

 Before any \ac{PE} calls a reduction routine, you must ensure that the
 following conditions exist (synchronization via a \OPR{barrier} or some other
 method is often needed to ensure this): The \VAR{pWrk} and \VAR{pSync} arrays on
 all \ac{PE}s in the \activeset{} are not still in use from a prior call to a
 collective \openshmem{} routine.  The \dest{} array on all \ac{PE}s in the \activeset{} 
 is ready to accept the results of the \OPR{reduction}.

 Upon return from a reduction routine, the following are true for the
 local \ac{PE}: The \dest{} array is updated.  The values in the \VAR{pSync} array
 are restored to the original values.
}
{
{
\hfill \\
 \desTBC{ When calling from \Fortran, the \dest{} date types are as follows:}
                {Routine}{Data Type}{
		  \cRow{shmem\_int8\_and\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_\_int4\_and\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_comp8\_max\_to\_all}{Complex, with an element size equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_max\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_max\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_max\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real16\_max\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int4\_min\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_min\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_min\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_min\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_min\_to\_all}{Real,with an element size of 16 bytes.}
		  \cRow{shmem\_comp4\_sum\_to\_all}{Complex, with an element size equal to two 4-byte real values.}
		  \cRow{shmem\_comp8\_sum\_to\_all}{Complex, with an element size equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_sum\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_sum\_to\_all}{Integer, with an element size of 8 bytes..}
		  \cRow{shmem\_real4\_sum\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_sum\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_sum\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_comp4\_prod\_to\_all}{ Complex, with an element size equal to two 4-byte real values. }		 
		  \cRow{shmem\_comp8\_prod\_to\_all}{ Complex, with an element size equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_prod\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_prod\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_prod\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_prod\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_prod\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int8\_or\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_or\_to\_all}{Integer, with an element size of 4 bytes.}
%		  \cRow{shmem\_comp8\_xor\_to\_all}{Complex, with an element size equal to two 8-byte real values.}
%		  \cRow{shmem\_comp4\_xor\_to\_all}{Complex, with an element size equal to two 4-byte real values.}
		  \cRow{shmem\_int8\_xor\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_xor\_to\_all}{Integer, with an element size of 4 bytes.}
%		  \cRow{shmem\_real8\_xor\_to\_all}{Real, with an element size of 8 bytes.}
%		  \cRow{shmem\_real4\_xor\_to\_all}{Real, with an element size of 4 bytes.}
		  }
}%end of DesB
{%Return Values     
\desR{None.}
}
% Notes. If there are no notes, this field can be left empty.
\notesB{  
 All \openshmem{} reduction routines reset the values in \VAR{pSync} before they
 return, so a particular \VAR{pSync} buffer need only be initialized the first
 time it is used.

 You must ensure that the \VAR{pSync} array is not being updated on any \ac{PE} in
 the \activeset{} while any of the \ac{PE}s participate in processing of an
 \openshmem{} reduction routine. Be careful to avoid the following situations:
 If the \VAR{pSync} array is initialized at run time, some type of synchronization is needed to
 ensure that all \ac{PE}s in the working set have initialized \VAR{pSync} before any of 
 them enter an \openshmem routine called
 with the \VAR{pSync} synchronization array. A \VAR{pSync} or \VAR{pWrk} array can be
 reused in a subsequent reduction routine call only if none of the \ac{PE}s
 in the \activeset{} are still processing a prior reduction routine call
 that used the same \VAR{pSync} or \VAR{pWrk} arrays. In general, this can be
 assured only by doing some type of synchronization. 
% However, in the
% special case of reduction routines being called with the same \activeset, 
% you can allocate two \VAR{pSync} and \VAR{pWrk} arrays and alternate between
% them on successive calls.
}
}
%Example
\exampleB{
%For each example, you can enter it as an item.
                  \exampleITEMF
                  { This \Fortran{} reduction example statically initializes the \VAR{pSync} array and finds the logical \OPR{AND} of the integer variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_and_example.f90}
                  {}
                   \exampleITEMF
	          {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{maximum} value of real variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_max_example.f90}
                  {}
                  \exampleITEMF
                  { This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{minimum} value of real variable \VAR{FOO} across all the even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_min_example.f90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{sum} of the real variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_sum_example.f90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the \OPR{product} of the real variable \VAR{FOO} across all the even \ac{PE}s.}
                  {./EXAMPLES/shmem_prod_example.f90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the logical \OPR{OR} of the integer variable \VAR{FOO} across all even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_or_example.f90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and computes the exclusive \OPR{XOR} of variable \VAR{FOO} across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_xor_example.f90}
                   {} 
                 }  	
\eAPI 



