\apisummary{
    Each \ac{PE} exchanges distinct data with all other \acp{PE} in the defined
    set. Each \ac{PE} may send a different amount of data and provide offsets
    for the \VAR{source} and \VAR{dest} data.
}

\begin{apidefinition}

\begin{Csynopsis}
void shmem_alltoallv(void *dest, size_t *t_offsets, size_t *t_sizes, const void *source, size_t *s_offsets, size_t *s_sizes, int PE_start, int logPE_stride, int PE_size, long *pSync)
\end{Csynopsis}

\begin{Fsynopsis}
INTEGER pSync(SHMEM_ALLTOALL_SYNC_SIZE)
INTEGER PE_start, logPE_stride, PE_size
INTEGER (KIND=8) t_offsets(*), t_sizes(*), s_offsets(*), s_sizes(*)
CALL SHMEM_ALLTOALLV(dest, t_offsets, t_sizes, source, s_offsets, s_sizes, PE_start, logPE_stride, PE_size, pSync)
\end{Fsynopsis}

\begin{apiarguments}
\apiargument{OUT}{dest}{A symmetric array large enough to receive the data
    being sent from each \ac{PE} in the \activeset.}
\apiargument{IN}{t\_offsets}{A symmetric array with \VAR{PE\_size} entries. Entry
    i specifies the offset (relative to \VAR{dest}) at which to place the
    incoming data from \ac{PE} i.}
\apiargument{OUT}{t\_sizes}{A symmetric array with \VAR{PE\_size} entries. On
    function return, entry i will contain the number of bytes received from
    \ac{PE} i.}
\apiargument{IN}{source}{A symmetric array that contains the data to be sent to
    each \ac{PE} in the \activeset.}
\apiargument{IN}{s\_offsets}{A symmetric array with \VAR{PE\_size} entries. Entry
    i specifies the offset (relative to \VAR{source}) of the starting address of
    the data to be sent to \ac{PE} i.}
\apiargument{IN}{s\_sizes}{A symmetric array with \VAR{PE\_size} entries. Entry i
    specifies the amount of data (in bytes) that will be sent to \ac{PE} i.}
\apiargument{IN}{PE\_start}{The lowest \ac{PE} number of the \activeset{} of
    \acp{PE}.  \VAR{PE\_start} must be of type integer.  If you are using
    \Fortran, it must be a default integer value.}
\apiargument{IN}{logPE\_stride}{The log (base 2) of the stride between
    consecutive \ac{PE} numbers in the \activeset.  \VAR{logPE\_stride} must be of
    type integer.  If you are using \Fortran, it must be a default integer value.}
\apiargument{IN}{PE\_size}{The number of \acp{PE} in the \activeset.
    \VAR{PE\_size} must be of type integer.  If you are using \Fortran, it must
    be a default integer value.}
\apiargument{IN}{pSync}{A symmetric work array. In \CorCpp, \VAR{pSync} must be
    of type long and size \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}. In \Fortran,
    \VAR{pSync} must be of type integer and size
    \CONST{SHMEM\_REDUCE\_SYNC\_SIZE}.  If you are using \Fortran, it must be a
    default integer value. Every element of this array must be initialized with
    the value \CONST{\_SHMEM\_SYNC\_VALUE} (in \CorCpp) or
    \CONST{SHMEM\_SYNC\_VALUE} (in \Fortran) before any of the \acp{PE} in the
    \activeset{} enter the reduction routine.}

\end{apiarguments}

\apidescription{
    The \FUNC{shmem\_alltoallv} routine is a collective routine; each \ac{PE} in
    the defined set exchanges distinct data with all other \acp{PE} in the set.
    Each \ac{PE} specifies an array of source offsets and source sizes (in
    bytes) that describe what data to send to each of the other \acp{PE} in the
    set.  The caller also specifies a \VAR{dest} buffer and a dest offset
    array that specifies where data received from each of the other \acp{PE} is
    deposited. The \VAR{t\_sizes} array is an output parameter. On return from
    the collective, the \VAR{t\_sizes} array contains the actual amount of data
    in bytes the local \ac{PE} received from each \ac{PE}.

    The \FUNC{shmem\_alltoallv} routine requires each PE to allocate its
    \VAR{dest} array large enough to hold the incoming data. If the caller
    calculates the \VAR{t\_offsets} using a smaller maximum size than is being
    used by one or more of the senders, data may be overwritten.  

    As with all \openshmem collective routines, this routine assumes
    that only \acp{PE} in the \activeset{} call the routine.  If a \ac{PE} not
    in the \activeset{} calls an \openshmem collective routine, undefined
    behavior results.

    The values of arguments \VAR{length}, \VAR{PE\_start}, \VAR{logPE\_stride},
    and \VAR{PE\_size} must be equal on all \acp{PE} in the \activeset. The same
    \VAR{dest} and \VAR{source} arrays, and the same \VAR{pSync} work array must
    be passed to all \acp{PE} in the \activeset.
    
    Before any \ac{PE} calls \FUNC{shmem\_alltoallv}, the following conditions
    must exist (synchronization via a barrier or some other method is often
    needed to ensure this): The \VAR{pSync} array on all \acp{PE} in the
    \activeset{} is not still in use from a prior call to a
    \FUNC{shmem\_alltoall/v} routine.  The \VAR{dest} array on all \acp{PE} in
    the \activeset{} is ready to accept the \FUNC{shmem\_alltoallv} data.
    
    Upon return from \FUNC{shmem\_alltoallv}, the following is true for the
    local PE: The \VAR{dest} array is updated.
}

\apireturnvalues{
    None.
}

\apinotes{
    This routine restores \VAR{pSync} to its original contents.  Multiple calls
    to \openshmem routines that use the same \VAR{pSync} array do not require
    that \VAR{pSync} be reinitialized after the first call.
    
    You must ensure the that the \VAR{pSync} array is not being updated by any
    \ac{PE} in the \activeset{} while any of the \acp{PE} participates in
    processing of an \openshmem \FUNC{shmem\_alltoallv} routine. Be careful to
    avoid these situations: If the \VAR{pSync} array is initialized at run
    time, some type of synchronization is needed to ensure that all \acp{PE} in
    the \activeset{} have initialized \VAR{pSync} before any of them enter an
    \openshmem routine called with the \VAR{pSync} synchronization array.  A
    \VAR{pSync} array may be reused on a subsequent \openshmem
    \FUNC{shmem\_alltoallv} routine only if none of the \acp{PE} in the
    \activeset{} are still processing a prior \openshmem
    \FUNC{shmem\_alltoallv} routine call that used the same \VAR{pSync} array.
    In general, this can be ensured only by doing some type of synchronization.        
}

\begin{apiexamples}

\apicexample
    {This example shows \FUNC{shmem\_alltoallv} exchanging variable sized
    data amounts among all \acp{PE}.}
    {./example_code/shmem_alltoallv_example.c}
    {}

\end{apiexamples}

\end{apidefinition}
