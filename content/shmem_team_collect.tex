\apisummary{
    Concatenates blocks of data from multiple \acp{PE} in a team to an array in every
    \ac{PE} in the team.
}

\begin{apidefinition}

\begin{Csynopsis}
void @\FuncDecl{shmem\_team\_collect32}@(shmem_team_t team, void *dest, const void *source, size_t nelems);
void @\FuncDecl{shmem\_team\_collect64}@(shmem_team_t team, void *dest, const void *source, size_t nelems);
void @\FuncDecl{shmem\_team\_fcollect32}@(shmem_team_t team, void *dest, const void *source, size_t nelems);
void @\FuncDecl{shmem\_team\_fcollect64}@(shmem_team_t team, void *dest, const void *source, size_t nelems);
\end{Csynopsis}

\begin{apiarguments}

\apiargument{IN}{team}{A valid \openshmem team handle to a team which has been
    created without disabling support for collective operations.}
\apiargument{OUT}{dest}{A symmetric array large enough
    to accept the concatenation of the \source{} arrays on all \acp{PE} in the team.
    See table below in this description for allowable data types.}
\apiargument{IN}{source}{A symmetric data object that can be of any type permissible
    for the \dest{} argument.}
\apiargument{IN}{nelems}{The number of elements in the \source{} array. \VAR{nelems}
    must be of type \VAR{size\_t}.}

\end{apiarguments}

\apidescription{   
    \openshmem \FUNC{team\_collect} and \FUNC{team\_fcollect} are collective routines
    over an existing team. These routines concatenate \VAR{nelems}
    \CONST{64}-bit or \CONST{32}-bit data items from the \source{} array into the
    \dest{} array, over all \acp{PE} in the specified \VAR{team} in processor number order.
    The resultant \dest{} array contains the contribution from the first \ac{PE} in the \VAR{team}
    , then the contribution from the second \ac{PE} in the \VAR{team}, and so on.
    The collected result is written to the \dest{} array for all \acp{PE} in the team.
    
    The \FUNC{fcollect} routines require that all \acp{PE} in the team provide the same
    value for \VAR{nelems}, while the \FUNC{collect} routines allow \VAR{nelems} to
    vary from \ac{PE} to \ac{PE}.

    If the team has been created with the \LibConstRef{SHMEM\_TEAM\_NOCOLLECTIVE} option,
    it will not have the required support structures to complete this routine. If
    such a team is passed to this or any other team collective routine, the behavior
    is undefined.

    The same \dest{} and \source{} data objects must be passed by all \acp{PE}
    in the team.

    Upon return from a collective routine, the following are true for the local
    \ac{PE}:
    \begin{itemize}
    \item The \dest{} array is updated.
    \item The \source{} array may be safely reused.
    \end{itemize}

    Error checking will be done to detect a value of \LibConstRef{SHMEM\_TEAM\_NULL} passed
    for the team argument. In that case, the program will abort with an informative
    error message. If an invalid team handle is passed to the routine,
    the behavior is undefined.
}

\apidesctable{
The  \dest{}  and \source{} data  objects must conform to certain typing
constraints, which are as follows:
}{Routine}{Data type of \VAR{dest} and \VAR{source}}

\apitablerow{shmem\_team\_collect64, shmem\_team\_fcollect64}{Any noncharacter
    type that has an element size of \CONST{64} bits.
    \CorCpp{} structures are NOT allowed.}
\apitablerow{shmem\_team\_collect32, shmem\_team\_fcollect32}{Any noncharacter
    type that has an element size of \CONST{32} bits.
    \CorCpp{} structures are NOT allowed.}

\apireturnvalues{
    None.
}

\apinotes{
    All \openshmem team collective routines use symmetric data structures associated
    with the team to synchronize and share data. By default, new teams that result from
    split operations will have these structures.
}

\begin{apiexamples}

\end{apiexamples}

\end{apidefinition}
