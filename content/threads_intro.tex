This section specifies the interaction between \openshmem{} interfaces and the
user threads, and also describes the routines that can be used for initializing and 
querying the thread environment.
 

\begin{itemize}

\item
A multithreaded \openshmem{} \ac{PE} using thread-compliant implementation can issue
\openshmem{} calls from  any of its threads. However, the threads
are not separately addressable. The symmetric heap and symmetric variables scope
are not impacted by multiple threads invoking the
\openshmem{} interfaces, i.e., 
each \ac{PE} has a single symmetric data segment and symmetric heap that is shared by
all threads within that \ac{PE}.  For example, a thread invoking a memory allocation
routine such as \FUNC{shmem\_malloc()} 
allocates memory that is accesible by all threads of the \ac{PE}. 
The requirement that the same symmetric heap operations must
be executed by all processes in the same order also applies in a threaded
environment. 
                                    	
\item In a thread-compliant implementation, 
all \openshmem{} calls are thread-safe, i.e., two concurrently running threads
may make \openshmem{} calls and the outcome will be as if the calls executed in
some order, even if their execution is interleaved.

\item Blocking \openshmem{} calls will block the calling thread only, allowing another
thread to execute, if available. The calling thread will be blocked until the
event on which it is waiting occurs. Once the blocked communication is enabled
and can proceed, then the call will complete and the thread will be marked
runnable, within a finite time. A blocked thread will not prevent progress of
other runnable threads on the same \ac{PE}, and will not prevent them from
executing other \openshmem{} calls. Also, a blocked thread will not prevent the
progress of other \openshmem{} calls on other \acp{PE}. 
 
\item
In a thread-compliant implementation, if multiple threads call the collective
calls, it is the programmer's responsibility to ensure the correct ordering of
collective calls.  The symmetric heap management functions, which are defined to call
\FUNC{shmem\_barrier\_all()}(\ref{sec:mem_routines}) before they return 
must be treated as collective operations.

\item
\openshmem{} thread calling \FUNC{shmem\_init()} is designated as the main thread.
Multiple threads may not call \FUNC{shmem\_init()}. Similarly, \openshmem{} finalize
may only be called on the main thread.

\end{itemize} 
 
{\bf Clarifications:}
 
\begin{itemize}
%\item[]
%The \openshmem{} specification can be implemented without support for threads.
%The \openshmem{} implementations are not required to be thread complaint.
%Regardless of whether \openshmem{} is thread complaint or not, SHMEM\_INIT(),
%SHMEM\_FINALIZE(), SHMEM\_GLOBALEXIT(), SHMEM\_INFO\_GET\_NAME(), and
%SHMEM\_INFO\_GET\_VERSION() should be thread safe.
 
%\item[]
%Interaction with signals: The outcome is undefined if a thread that executes an
%\openshmem{} call catches a signal. However, a thread of an \openshmem{} process
%may terminate, and may catch signals or be canceled by another thread when not
%executing \openshmem{} calls.

\item[]
The completion semantics are not impacted by the multiple threads. 
For example, the \FUNC{shmem\_barrier\_all()} is completed when all \acp{PE} enter and
exit the \FUNC{shmem\_barrier\_all()} call, even though only one thread in the \ac{PE} is
participating in the collective call. 

 
\end{itemize}
