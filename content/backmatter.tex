\clearpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

%defining pagestyle for annex
%\pagestyle{plain} \withlinenumbers
\pagestyle{fancy} \withlinenumbers
\fancyhf{}
\fancyhead[RE, LO]{\leftmark}
\fancyhead[RO, LE]{\thepage}
\fancyfoot[CE,CO]{\thepage}
\renewcommand{\headrulewidth}{0pt}




\chapter{Writing OpenSHMEM Programs}
\section*{Incorporating OpenSHMEM into Programs}\label{sec:writing_programs}

The following section describes how to write a ``Hello World" \openshmem program.
To write a ``Hello World" \openshmem program, the user must:

\begin{itemize}
\item Include the header file \HEADER{shmem.h} for \Cstd or \HEADER{shmem.fh} for \Fortran.
\item Add the initialization call \hyperref[subsec:shmem_init]{\FUNC{shmem\_init}}.
\item Use OpenSHMEM calls to query the local PE number
    (\hyperref[subsec:shmem_my_pe]{\FUNC{shmem\_my\_pe}}) and the total number
    of PEs (\hyperref[subsec:shmem_n_pes]{\FUNC{shmem\_n\_pes}}).
\item Add the finalization call \hyperref[subsec:shmem_finalize]{\FUNC{shmem\_finalize}}.
\end{itemize}

In \openshmem, the order in which lines appear in the output is not
deterministic because \acp{PE} execute asynchronously in parallel.

\begin{minipage}{\linewidth}
\vspace{0.1in}
\numberedlisting{caption={``Hello World'' example program in \Cstd},label=openshmem-hello,language=OSH2+C}
                {example_code/hello-openshmem.c}
\outputlisting{language=bash,caption={Possible ordering of expected output with 4 \acp{PE} from the program in Listing~\ref{openshmem-hello}}}
                {example_code/hello-openshmem-c.output}
\vspace{0.1in}
\end{minipage}

\clearpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{deprecate}
\openshmem also provides a \Fortran API. Listing~\ref{openshmem-hello-f90} shows a similar program written in \Fortran.

\begin{minipage}{\linewidth}
\vspace{0.1in}
\numberedlisting{caption={``Hello World'' example program in \Fortran},label=openshmem-hello-f90,language=OSH2+F}
                {example_code/hello-openshmem.f90}
\outputlisting{language=bash,caption={Possible ordering of expected output with 4 \acp{PE} from the program in Listing~\ref{openshmem-hello-f90}}}
                {example_code/hello-openshmem-f90.output}
\vspace{0.1in}
\end{minipage}
\end{deprecate}

\clearpage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The example in Listing~\ref{openshmem-hello-symmetric} shows a more complex
\openshmem program that illustrates the use of symmetric data objects.
Note the declaration of the \VAR{static short dest} array and its use as the
remote destination in \hyperref[subsec:shmem_put]{\FUNC{shmem\_put}}.

The \VAR{static} keyword makes the \VAR{dest} array symmetric on all \acp{PE}.
%% FIXME: The following sentence is not *technically* correct.
Each \ac{PE} is able to transfer data to the \dest{} array by simply specifying
the local address of the symmetric data object that will receive the data.
This local address resolution aids programmability because the address of the
\dest{} need not be exchanged with the active side (\ac{PE} \CONST{0}) prior to
the RMA (Remote Memory Access) routine.

Conversely, the declaration of the \VAR{short source} array is asymmetric
(local only).
The \source{} object does not need to be symmetric because \PUT{} handles the
references to the \VAR{source} array only on the active (local) side.

\begin{minipage}{\linewidth}
\vspace{0.1in}
\numberedlisting{caption={Example program with symmetric data objects},label=openshmem-hello-symmetric,language=OSH2+C}
                {example_code/writing_shmem_example.c}
\outputlisting{language=bash,caption={Possible ordering of expected output with 4 \acp{PE} from the program in Listing~\ref{openshmem-hello-symmetric}}}
                {example_code/writing_shmem_example.output}
\vspace{0.1in}
\end{minipage}




\chapter{Compiling and Running Programs}\label{sec:compiling}
The specification does not specify how
\openshmem programs are compiled, linked, and run. This section shows some
examples of how wrapper programs are utilized in the \openshmem Reference
Implementation to compile and launch programs.

\section{Compilation}
\subsection*{Programs written in \Cstd}

The \openshmem Reference Implementation provides a wrapper program, named
\textbf{oshcc}, to aid in the compilation of \Cstd programs.
The wrapper may be called as follows:

\begin{lstlisting}[language=bash]
oshcc <compiler options> -o myprogram myprogram.c
\end{lstlisting}
Where the $\langle\mbox{compiler options}\rangle$ are options understood by the
underlying \Cstd compiler called by \textbf{oshcc}.


\subsection*{Programs written in \Cpp}

The \openshmem Reference Implementation provides a wrapper program, named
\textbf{oshCC}, to aid in the compilation of \Cpp programs.
The wrapper may be called as follows:

\begin{lstlisting}[language=bash]
oshCC <compiler options> -o myprogram myprogram.cpp
\end{lstlisting}
Where the $\langle\mbox{compiler options}\rangle$ are options understood by the
underlying \Cpp compiler called by \textbf{oshCC}.


\subsection*{Programs written in \Fortran}

\begin{deprecate}
The \openshmem Reference Implementation provides a wrapper program, named
\textbf{oshfort}, to aid in the compilation of \Fortran programs.
The wrapper may be called as follows:

\begin{lstlisting}[language=bash]
oshfort <compiler options> -o myprogram myprogram.f
\end{lstlisting}
Where the $\langle\mbox{compiler options}\rangle$ are options understood by the
underlying \Fortran compiler called by \textbf{oshfort}.
\end{deprecate}

\section{Running Programs}

The \openshmem Reference Implementation provides a wrapper program, named
\textbf{oshrun}, to launch \openshmem programs.
The wrapper may be called as follows:

\begin{lstlisting}[language=bash]
oshrun <additional options> -np <#> <program> <program arguments>
\end{lstlisting}
The program arguments for \textbf{oshrun} are:

\begin{tabular}{p{0.3\textwidth}p{0.6\textwidth}}
$\langle\mbox{additional options}\rangle$ & {Options passed to the underlying launcher.}\tabularnewline
-np $\langle\mbox{\#}\rangle$ & {The number of \acp{PE} to be used in the execution.}\tabularnewline
$\langle\mbox{program}\rangle$ & {The program executable to be launched.}\tabularnewline
$\langle\mbox{program arguments}\rangle$ & {Flags and other parameters to pass to the program.}\tabularnewline
\end{tabular}




\chapter{Undefined Behavior in OpenSHMEM}\label{sec:undefined}

The specification formalizes the expected behavior of
its library routines.  In cases where routines are improperly used
or the input is not in accordance with the specification, undefined
behavior is observed.  Depending on the implementation, there are
many interpretations of undefined behavior. 

$\;$

$ $%
\begin{tabular}{|>{\raggedright}p{0.3\textwidth}|>{\raggedright}p{0.6\textwidth}|}
\hline 
\textbf{Inappropriate Usage} & \textbf{Undefined Behavior}\tabularnewline
\hline 
\hline 
Uninitialized library & If the \openshmem library is not initialized,
calls to non-initializing \openshmem routines have undefined
behavior.  For example, an implementation may try to continue or may abort
immediately upon an \openshmem call into the uninitialized library.
\tabularnewline
\hline
Multiple calls to initialization routines & In an OpenSHMEM program where
an initialization routine (\FUNC{shmem\_init} or \FUNC{shmem\_init\_thread})
has already been called, any subsequent calls to an initialization routine
result in undefined behavior.
\tabularnewline
\hline
Accessing non-existent \acp{PE} & If a communications routine accesses a
non-existent \ac{PE}, then the \openshmem library may handle this
situation in an implementation-defined way.  For example, the library may report
an error message saying that the \ac{PE} accessed is outside the range of
accessible \acp{PE}, or may exit without a warning.\tabularnewline
\hline 
Use of non-symmetric variables & Some routines require remotely accessible
variables to perform their function.  For example, a \PUT{} to a non-symmetric variable may
be trapped where possible and the library may abort the program.  Another
implementation may choose to continue execution with or without a warning.
\tabularnewline
\hline 
Non-symmetric memory allocation & The symmetric memory management routines are
collectives. For example, all \acp{PE} in the program must call
\FUNC{shmem\_malloc} with the same \VAR{size} argument.  Program behavior after a
mismatched \FUNC{shmem\_malloc} call is undefined.\tabularnewline
\hline 
Use of null pointers with non-zero \VAR{len} specified & In any \openshmem routine
that takes a pointer and \VAR{len} describing the number of elements in that
pointer, a null pointer may not be given unless the corresponding \VAR{len} is also
specified as zero. Otherwise, the resulting behavior is undefined.
The following cases summarize this behavior:
\begin{itemize}
    \item \VAR{len} is 0, pointer is null: supported.
    \item \VAR{len} is not 0, pointer is null: undefined behavior.
    \item \VAR{len} is 0, pointer is non-null: supported.
    \item \VAR{len} is not 0, pointer is non-null: supported.
\end{itemize}
\tabularnewline
\hline 
\end{tabular}




\chapter{Interoperability with other Programming Models}\label{sec:mpi}

\section{\ac{MPI} Interoperability}

\begin{sloppypar} % to prevent constants from running into margins.
%
\openshmem routines may be used in conjunction with \ac{MPI} routines in the
same program.  For example, on \ac{SGI} systems, programs that use both \ac{MPI} and
\openshmem routines call \FUNC{MPI\_Init} and \FUNC{MPI\_Finalize} but omit the
call to the \FUNC{shmem\_init} routine.  \openshmem \ac{PE} numbers are equal to
the \ac{MPI} rank within the \CONST{MPI\_COMM\_WORLD} environment variable.
Note that this indexing precludes use of \openshmem routines between processes in
different \CONST{MPI\_COMM\_WORLD}s.  For example, \ac{MPI} processes started using the
\FUNC{MPI\_Comm\_spawn} routine cannot use \openshmem routines to
communicate with their parent \ac{MPI} processes.
%
\end{sloppypar}
%
On \ac{SGI} systems where \ac{MPI} jobs use \ac{TCP}/sockets for inter-host communication,
\openshmem routines may be used to communicate with processes running on the
same host.  The \FUNC{shmem\_pe\_accessible} routine should be used to determine if
a remote \ac{PE} is accessible via \openshmem communication from the local
\ac{PE}. When running an \ac{MPI} program involving multiple executable files,
\openshmem routines may be used to communicate with processes running from the
same or different executable files, provided that the communication is limited
to symmetric data objects.  On these systems, static memory---such as a
\Fortran common block or \Cstd global variable---is symmetric between
processes running from the same executable file, but is not symmetric between
processes running from different executable files.  Data allocated from the
symmetric heap (e.g., \FUNC{shmem\_malloc}, \FUNC{shpalloc}) is symmetric across the
same or different executable files. The \FUNC{shmem\_addr\_accessible} routine
should be used to determine if a local address is accessible via \openshmem
communication from a remote \ac{PE}.

Another important feature of these systems is that the
\FUNC{shmem\_pe\_accessible} routine returns \CONST{TRUE} only if the remote
\ac{PE} is a process running from the same executable file as the local \ac{PE},
indicating that full \openshmem support (static memory and symmetric heap) is
available.  When using \openshmem routines within an \ac{MPI} program, the use
of \ac{MPI} memory-placement environment variables is required when using
non-default memory-placement options.




\chapter{History of OpenSHMEM}\label{sec:openshmem_history}

SHMEM has a long history as a parallel programming model, having been used
extensively on a number of products since 1993, including Cray T3D, Cray X1E,
the Cray XT3/4, \ac{SGI} Origin, \ac{SGI} Altix, clusters based on the Quadrics
interconnect, and, to a very limited extent, Infiniband based clusters.

\begin{itemize}
\item A SHMEM Timeline
  \begin{itemize}
  \item Cray SHMEM
    \begin{itemize}
    \item SHMEM first introduced by Cray Research Inc. in 1993 for Cray T3D
    \item Cray is acquired by \ac{SGI} in 1996
    \item Cray is acquired by Tera in 2000 (MTA)
    \item Platforms: Cray T3D, T3E, C90, J90, SV1, SV2, X1, X2, XE, XMT, XT
    \end{itemize}
  \item \ac{SGI} SHMEM
    \begin{itemize}
    \item \ac{SGI} purchases  Cray Research Inc. and SHMEM was integrated into
      \ac{SGI}'s Message Passing Toolkit (MPT)
    \item \ac{SGI} currently owns the rights to SHMEM and \openshmem
    \item Platforms: Origin, Altix 4700, Altix XE, ICE, UV
    \item \ac{SGI} was purchased by Rackable Systems in 2009
    \item \ac{SGI} and Open Source Software Solutions, Inc. (OSSS) signed a
      SHMEM trademark licensing agreement, in 2010
    \end{itemize}
  \item Other Implementations
    \begin{itemize}
    \item Quadrics (Vega UK, Ltd.)
    \item Hewlett Packard
    \item GPSHMEM
    \item IBM
    \item QLogic
    \item Mellanox
    % \item University of Houston
    \item University of Florida
    \end{itemize}
  \end{itemize}
\item OpenSHMEM Implementations 
 \begin{itemize}
  \item \ac{SGI} \openshmem
  \item University of Houston - \openshmem Reference Implementation
  \item Mellanox ScalableSHMEM
  \item Portals-SHMEM
  \item IBM OpenSHMEM
  \end{itemize}
\end{itemize}








\chapter{OpenSHMEM Specification and Deprecated API}\label{sec:dep_api}

\section{Overview}\label{subsec:dep_overview}
For the \openshmem specification, deprecation is the process of identifying
API that is supported but no longer recommended for use by program users. For
\openshmem library users, said API \textbf{must} be supported until clearly
indicated as otherwise by the specification.
This chapter records the API or functionality that have been deprecated, the
\openshmem specification version that effected the deprecation, and the
\openshmem specification version that the feature was last supported before
removal.

\begin{center}
\scriptsize
\begin{tabular}{|l|c|c|l|}
    \hline
    \textbf{Deprecated API}
    & \textbf{Deprecated Since}
    & \shortstack{\textbf{Last Version Supported}}
    & \textbf{Replaced By} \\
    \hline
    Header Directory: \hyperref[subsec:dep_rationale:mpp]{\HEADER{mpp}} & 1.1 & Current & (none) \\ \hline
    \CorCpp: \hyperref[subsec:start_pes]{\FUNC{start\_pes}} & 1.2 & Current & \hyperref[subsec:shmem_init]{\FUNC{shmem\_init}} \\ \hline
    \Fortran: \hyperref[subsec:start_pes]{\FUNC{START\_PES}} & 1.2 & Current & \hyperref[subsec:shmem_init]{\FUNC{SHMEM\_INIT}} \\ \hline
    \hyperref[subsec:start_pes]{Implicit finalization} & 1.2 & Current & \hyperref[subsec:shmem_finalize]{\FUNC{shmem\_finalize}} \\ \hline
    \CorCpp: \FUNC{\_my\_pe} & 1.2 & Current & \hyperref[subsec:shmem_my_pe]{\FUNC{shmem\_my\_pe}} \\ \hline
    \CorCpp: \FUNC{\_num\_pes} & 1.2 & Current & \hyperref[subsec:shmem_n_pes]{\FUNC{shmem\_n\_pes}} \\ \hline
    \Fortran: \FUNC{MY\_PE} & 1.2 & Current & \hyperref[subsec:shmem_my_pe]{\FUNC{SHMEM\_MY\_PE}} \\ \hline
    \Fortran: \FUNC{NUM\_PES} & 1.2 & Current & \hyperref[subsec:shmem_n_pes]{\FUNC{SHMEM\_N\_PES}} \\ \hline
    \CorCpp: \FUNC{shmalloc} & 1.2 & Current & \hyperref[subsec:shfree]{\FUNC{shmem\_malloc}} \\ \hline
    \CorCpp: \FUNC{shfree} & 1.2 & Current & \hyperref[subsec:shfree]{\FUNC{shmem\_free}} \\ \hline
    \CorCpp: \FUNC{shrealloc} & 1.2 & Current & \hyperref[subsec:shfree]{\FUNC{shmem\_realloc}} \\ \hline
    \CorCpp: \FUNC{shmemalign} & 1.2 & Current & \hyperref[subsec:shfree]{\FUNC{shmem\_align}} \\ \hline
    \Fortran: \FUNC{SHMEM\_PUT} & 1.2 & Current & \hyperref[subsec:shmem_put]{\FUNC{SHMEM\_PUT8} or \FUNC{SHMEM\_PUT64}} \\ \hline
    \shortstack[l]{\CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_clear\_cache\_inv}}
        \\ \Fortran: \hyperref[subsec:shmem_cache]{\FUNC{SHMEM\_CLEAR\_CACHE\_INV}}}
        & 1.3 & Current & (none) \\ \hline
    \CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_clear\_cache\_line\_inv}} & 1.3 & Current & (none) \\ \hline
    \shortstack[l]{\CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_set\_cache\_inv}}
        \\ \Fortran: \hyperref[subsec:shmem_cache]{\FUNC{SHMEM\_SET\_CACHE\_INV}}}
        & 1.3 & Current & (none) \\ \hline
    \shortstack[l]{\CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_set\_cache\_line\_inv}}
        \\ \Fortran: \hyperref[subsec:shmem_cache]{\FUNC{SHMEM\_SET\_CACHE\_LINE\_INV}}}
        & 1.3 & Current & (none) \\ \hline
    \shortstack[l]{\CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_udcflush}}
        \\ \Fortran: \hyperref[subsec:shmem_cache]{\FUNC{SHMEM\_UDCFLUSH}}}
        & 1.3 & Current & (none) \\ \hline
    \shortstack[l]{\CorCpp: \hyperref[subsec:shmem_cache]{\FUNC{shmem\_udcflush\_line}}
        \\ \Fortran: \hyperref[subsec:shmem_cache]{\FUNC{SHMEM\_UDCFLUSH\_LINE}}}
        & 1.3 & Current & (none) \\ \hline
    \CONST{\_SHMEM\_SYNC\_VALUE}         & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_SYNC\_VALUE}} \\ \hline
    \CONST{\_SHMEM\_BARRIER\_SYNC\_SIZE} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_BARRIER\_SYNC\_SIZE}} \\ \hline
    \CONST{\_SHMEM\_BCAST\_SYNC\_SIZE}   & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_BCAST\_SYNC\_SIZE}} \\ \hline
    \CONST{\_SHMEM\_COLLECT\_SYNC\_SIZE} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_COLLECT\_SYNC\_SIZE}} \\ \hline
    \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}  & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_REDUCE\_SYNC\_SIZE}} \\ \hline
    \CONST{\_SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}} \\ \hline
    \CONST{\_SHMEM\_MAJOR\_VERSION} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_MAJOR\_VERSION}} \\ \hline
    \CONST{\_SHMEM\_MINOR\_VERSION} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_MINOR\_VERSION}} \\ \hline
    \CONST{\_SHMEM\_MAX\_NAME\_LEN} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_MAX\_NAME\_LEN}} \\ \hline
    \CONST{\_SHMEM\_VENDOR\_STRING} & 1.3 & Current & \hyperref[subsec:library_constants]{\CONST{SHMEM\_VENDOR\_STRING}} \\ \hline
    \VAR{SMA\_VERSION}         & 1.4 & Current & \hyperref[subsec:environment_variables]{\VAR{SHMEM\_VERSION}} \\ \hline
    \VAR{SMA\_INFO}            & 1.4 & Current & \hyperref[subsec:environment_variables]{\VAR{SHMEM\_INFO}} \\ \hline
    \VAR{SMA\_SYMMETRIC\_SIZE} & 1.4 & Current & \hyperref[subsec:environment_variables]{\VAR{SHMEM\_SYMMETRIC\_SIZE}} \\ \hline
    \VAR{SMA\_DEBUG}           & 1.4 & Current & \hyperref[subsec:environment_variables]{\VAR{SHMEM\_DEBUG}} \\ \hline
    \CorCpp: \FUNC{shmem\_wait}  & 1.4 & Current & See ``Notes'' for \hyperref[subsec:shmem_wait]{\FUNC{shmem\_wait\_until}} \\ \hline
    \CorCpp: \FUNC{shmem\_fetch} & 1.4 & Current & \hyperref[subsec:shmem_atomic_fetch]{\FUNC{shmem\_atomic\_fetch}} \\ \hline
    \CorCpp: \FUNC{shmem\_set}   & 1.4 & Current & \hyperref[subsec:shmem_atomic_set]{\FUNC{shmem\_atomic\_set}} \\ \hline
    \CorCpp: \FUNC{shmem\_cswap} & 1.4 & Current & \hyperref[subsec:shmem_atomic_compare_swap]{\FUNC{shmem\_atomic\_compare\_swap}} \\ \hline
    \CorCpp: \FUNC{shmem\_swap}  & 1.4 & Current & \hyperref[subsec:shmem_atomic_swap]{\FUNC{shmem\_atomic\_swap}} \\ \hline
    \CorCpp: \FUNC{shmem\_finc}  & 1.4 & Current & \hyperref[subsec:shmem_atomic_fetch_inc]{\FUNC{shmem\_atomic\_fetch\_inc}} \\ \hline
    \CorCpp: \FUNC{shmem\_inc}   & 1.4 & Current & \hyperref[subsec:shmem_atomic_inc]{\FUNC{shmem\_atomic\_inc}} \\ \hline
    \CorCpp: \FUNC{shmem\_fadd}  & 1.4 & Current & \hyperref[subsec:shmem_atomic_fetch_add]{\FUNC{shmem\_atomic\_fetch\_add}} \\ \hline
    \CorCpp: \FUNC{shmem\_add}   & 1.4 & Current & \hyperref[subsec:shmem_atomic_add]{\FUNC{shmem\_atomic\_add}} \\ \hline
    Entire \Fortran API & 1.4 & Current & (none) \\ \hline
    \end{tabular}
\end{center}

\section{Deprecation Rationale}\label{subsec:dep_rationale}

\subsection{Header Directory: \HEADER{mpp}}
\label{subsec:dep_rationale:mpp}
In addition to the default system header paths, \openshmem implementations
must provide all \openshmem standard header files from the \HEADER{mpp}
header directory such that headers can be referenced in \CorCpp as
\begin{lstlisting}[language=]
#include <mpp/shmem.h>
#include <mpp/shmemx.h>
\end{lstlisting}
and in \Fortran as
\begin{lstlisting}[language=]
include 'mpp/shmem.fh'
include 'mpp/shmemx.fh'
\end{lstlisting}
for backwards compatibility with \ac{SGI} SHMEM.

\subsection{\CorCpp: \FUNC{start\_pes}}
The \CorCpp routine \FUNC{start\_pes} includes an unnecessary initialization
argument that is remnant of historical \emph{SHMEM} implementations and no
longer reflects the requirements of modern \openshmem implementations.
Furthermore, the naming of \FUNC{start\_pes} does not include the standardized
\shmemprefixLC{} naming prefix. This routine has been deprecated and
\openshmem users are encouraged to use \FUNC{shmem\_init} instead.

\subsection{Implicit Finalization}
Implicit finalization has been replaced with explicit finalization using the
\FUNC{shmem\_finalize} routine.  Explicit finalization improves portability and
also improves interoperability with profiling and debugging tools.

\subsection{\CorCpp: \FUNC{\_my\_pe}, \FUNC{\_num\_pes}, \FUNC{shmalloc},
    \FUNC{shfree}, \FUNC{shrealloc}, \FUNC{shmemalign}}
The \CorCpp routines \FUNC{\_my\_pe}, \FUNC{\_num\_pes}, \FUNC{shmalloc},
\FUNC{shfree}, \FUNC{shrealloc}, and \FUNC{shmemalign} were deprecated in order
to normalize the \openshmem \ac{API} to use \shmemprefixLC{} as the standard
prefix for all routines.

\subsection{\Fortran: \FUNC{START\_PES}, \FUNC{MY\_PE}, \FUNC{NUM\_PES}}
The \Fortran routines \FUNC{START\_PES}, \FUNC{MY\_PE}, and \FUNC{NUM\_PES}
were deprecated in order to minimize the API differences from the deprecation
of \CorCpp routines \FUNC{start\_pes}, \FUNC{\_my\_pe}, and \FUNC{\_num\_pes}.

\subsection{\Fortran: \FUNC{SHMEM\_PUT}}
The \Fortran routine \FUNC{SHMEM\_PUT} is defined only for the \Fortran
\ac{API} and is semantically identical to \Fortran routines
\FUNC{SHMEM\_PUT8} and \FUNC{SHMEM\_PUT64}.  Since \FUNC{SHMEM\_PUT8} and
\FUNC{SHMEM\_PUT64} have defined equivalents in the \CorCpp interface,
\FUNC{SHMEM\_PUT} is ambiguous and has been deprecated.

\subsection{SHMEM\_CACHE}
The \FUNC{SHMEM\_CACHE} \ac{API}
\begin{center}
\begin{tabular}{ll}
    \CorCpp: & \Fortran: \\
    \FUNC{shmem\_clear\_cache\_inv}     & \FUNC{SHMEM\_CLEAR\_CACHE\_INV} \\
    \FUNC{shmem\_set\_cache\_inv}       & \FUNC{SHMEM\_SET\_CACHE\_INV} \\
    \FUNC{shmem\_set\_cache\_line\_inv} & \FUNC{SHMEM\_SET\_CACHE\_LINE\_INV} \\
    \FUNC{shmem\_udcflush}              & \FUNC{SHMEM\_UDCFLUSH} \\
    \FUNC{shmem\_udcflush\_line}        & \FUNC{SHMEM\_UDCFLUSH\_LINE} \\
    \FUNC{shmem\_clear\_cache\_line\_inv} \\
\end{tabular}
\end{center}
was originally implemented for systems with cache-management instructions.
This API has largely gone unused on cache-coherent system architectures.
\FUNC{SHMEM\_CACHE} has been deprecated.

\subsection{\CONST{\_SHMEM\_*} Library Constants}
The library constants
\begin{center}
\begin{tabular}{ll}
    \CONST{\_SHMEM\_SYNC\_VALUE}         & \CONST{\_SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE} \\
    \CONST{\_SHMEM\_BARRIER\_SYNC\_SIZE} & \CONST{\_SHMEM\_MAJOR\_VERSION} \\
    \CONST{\_SHMEM\_BCAST\_SYNC\_SIZE}   & \CONST{\_SHMEM\_MINOR\_VERSION} \\
    \CONST{\_SHMEM\_COLLECT\_SYNC\_SIZE} & \CONST{\_SHMEM\_MAX\_NAME\_LEN} \\
    \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}  & \CONST{\_SHMEM\_VENDOR\_STRING} \\
\end{tabular}
\end{center}
do not adhere to the \Cstd standard's reserved identifiers and the \Cpp
standard's reserved names.  These constants have been deprecated and replaced
with corresponding constants of prefix \shmemprefix{} that adhere to \CorCpp{}
and \Fortran naming conventions.

\subsection{\VAR{SMA\_*} Environment Variables}
The environment variables \VAR{SMA\_VERSION}, \VAR{SMA\_INFO},
\VAR{SMA\_SYMMETRIC\_SIZE}, and \VAR{SMA\_DEBUG}
were deprecated in order to normalize the \openshmem \ac{API} to use
\shmemprefix{} as the standard prefix for all environment variables.

\subsection{\CorCpp: \FUNC{shmem\_wait}}
The \CorCpp interface for \FUNC{shmem\_wait} was identified as unintuitive with respect to
the comparison operation it performed.  As \FUNC{shmem\_wait} can be trivially
replaced by \FUNC{shmem\_wait\_until} where \VAR{cmp} is
\CONST{SHMEM\_CMP\_NE}, the \FUNC{shmem\_wait} interface was deprecated in
favor of \FUNC{shmem\_wait\_until}, which makes the comparison operation
explicit and better communicates the developer's intent.

\subsection{\CorCpp: \FUNC{shmem\_fetch}, \FUNC{shmem\_set}, \FUNC{shmem\_cswap},
  \FUNC{shmem\_swap}, \FUNC{shmem\_finc}, \FUNC{shmem\_inc},
  \FUNC{shmem\_fadd}, \FUNC{shmem\_add}}

The \CorCpp interfaces for \FUNC{shmem\_fetch}, \FUNC{shmem\_set},
\FUNC{shmem\_cswap}, \FUNC{shmem\_swap}, \FUNC{shmem\_finc}, \FUNC{shmem\_inc},
\FUNC{shmem\_fadd}, and \FUNC{shmem\_add} were deprecated and replaced with
similarly named interfaces within the \FUNC{shmem\_atomic\_*} namespace
in order to more clearly identify these calls as performing atomic operations.
In addition, the abbreviated names ``cswap'', ``finc'', and ``fadd'' were
expanded for clarity to ``compare\_swap'', ``fetch\_inc'', and ``fetch\_add''.

\subsection{\Fortran API}\label{subsec:deprecate-fortran}
The entire \openshmem \Fortran API was deprecated because of a general lack of
use and a lack of conformance with legacy \Fortran standards. In lieu of an
extensive update of the \Fortran API, \Fortran users are encouraged to
leverage current and future \openshmem specifications of the \Cstd API
through the \Fortran-\Cstd interoperability initially standardized by
\Fortran[2003]%
\footnote{Formally, \Fortran[2003] is known as ISO/IEC~1539-1:2004(E).}.





\chapter{Changes to this Document}\label{sec:changelog}

\section{Version 1.4}
%Major changes in \openshmem[1.4] include ...

The following list describes the specific changes in \openshmem[1.4]:
\begin{itemize}

\item Clarified that the \openshmem extensions header files are required, even when empty.
\\See Section~\ref{subsec:bindings}.
%
\item Clarified that the \FUNC{SHMEM\_GET64} and \FUNC{SHMEM\_GET64\_NBI}
    routines are included in the \Fortran language bindings.\\
    See Sections \ref{subsec:shmem_get} and \ref{subsec:shmem_get_nbi}.
%
\item Clarified that \FUNC{shmem\_init} must be matched with a call to
    \FUNC{shmem\_finalize}.
\\See Sections \ref{subsec:shmem_init} and \ref{subsec:shmem_finalize}.
%
\item Added the \CONST{SHMEM\_SYNC\_SIZE} constant.
\\See Section \ref{subsec:library_constants}.
%
\item Added type-generic interfaces for \FUNC{SHMEM\_WAIT}.
\\ See Section \ref{subsec:shmem_wait}.
%
\item Removed the \VAR{volatile} qualifiers from the \VAR{ivar} arguments to
\FUNC{shmem\_wait} routines and the \VAR{lock} arguments in the lock API.
\emph{Rationale: Volatile qualifiers were added to several API routines in
version 1.3 of the OpenSHMEM specification; however, they were later found
to be unnecessary.}
\\ See Sections \ref{subsec:shmem_wait} and \ref{subsec:shmem_lock}.
%
\item Deprecated the \VAR{SMA\_}* environment variables and added equivalent
\VAR{SHMEM\_}* environment variables.
\\ See Section \ref{subsec:environment_variables}.
%
\item Added the \Cstd[11] \CTYPE{\_Noreturn} function specifier to
\FUNC{shmem\_global\_exit}.
\\ See Section \ref{subsec:shmem_global_exit}.
%
\item Clarified ordering semantics of memory ordering, point-to-point synchronization, and collective 
synchronization routines.
%
\item Clarified deprecation overview and added deprecation rationale in Annex F.
\\See Section \ref{sec:dep_api}.
%
\item Deprecated header directory \HEADER{mpp}.
\\See Section \ref{sec:dep_api}.
%
\item Deprecated the \VAR{shmem\_wait} functions and added \VAR{shmem\_test}
      functions.
\\ See Section \ref{subsec:p2p_intro}.
%
\item Added the \FUNC{shmem\_calloc} function.
\\ See Section \ref{subsec:shmem_calloc}.
%
\item Introduced the thread safe semantics that define the interaction between
    \openshmem routines and user threads.
\\See Section \ref{subsec:thread_support}.
%
\item Added the new routine \FUNC{shmem\_init\_thread} to initialize the
    \openshmem library with one of the defined thread levels.
\\See Section \ref{subsec:shmem_init_thread}.
%
\item Added the new routine \FUNC{shmem\_query\_thread} to query the thread
    level provided by the \openshmem implementation.
\\See Section \ref{subsec:shmem_query_thread}.
%
\item Clarified the semantics of \FUNC{shmem\_quiet} for a multithreaded
    \openshmem \ac{PE}.
\\See Section \ref{subsec:shmem_quiet}
%
\item Revised the description of \FUNC{shmem\_barrier\_all} for a multithreaded
    \openshmem \ac{PE}.
\\See Section \ref{subsec:shmem_barrier_all}
%
\item Revised the description of \FUNC{shmem\_wait} for a multithreaded
    \openshmem \ac{PE}.
\\See Section \ref{subsec:shmem_wait}
%
\item Clarified description for \CONST{SHMEM\_VENDOR\_STRING}.
\\See Section \ref{subsec:library_constants}.
%
\item Clarified description for \CONST{SHMEM\_MAX\_NAME\_LEN}.
\\See Section \ref{subsec:library_constants}.
%
\item Clarified API description for \FUNC{shmem\_info\_get\_name}.
\\See Section \ref{subsec:shmem_info_get_name}.
%
\item Expanded the type support for RMA and AMO operations.
\\ See Sections \ref{sec:rma} and \ref{sec:amo}.
%
\item Renamed AMO operations to use \FUNC{shmem\_atomic\_*} prefix and
      deprecated old AMO routines.
\\ See Section \ref{sec:amo}.
%
\item Added fetching and non-fetching bitwise AND, OR, and XOR atomic
      operations.
\\ See Section \ref{sec:amo}.
%
\item Deprecated the entire \Fortran API.
%
\item Replaced the \CTYPE{complex} macro in complex-typed reductions with the
      \Cstd[99] (and later) type specifier \CTYPE{\_Complex} to remove an
      implicit dependence on \HEADER{complex.h}.
\\ See Section \ref{subsec:shmem_reductions}.
%
\item Clarified that complex-typed reductions in C are optionally supported.
\\ See Section \ref{subsec:shmem_reductions}.
%
\end{itemize}




\section{Version 1.3}
Major changes in \openshmem[1.3] include the addition of
\Cstd[11] type-generic interfaces for \ac{RMA} and \ac{AMO} operations,
non-blocking RMA operations,
atomic \PUT{} and \GET{} operations,
and all-to-all collectives.

The following list describes the specific changes in \openshmem[1.3]:
\begin{itemize}
%
\item Clarified implementation of \acp{PE} as threads.
%
\item Added \CTYPE{const} to every read-only pointer argument.
%
\item Clarified definition of \OPR{Fence}.
\\See Section \ref{subsec:programming_model}.
%
\item Clarified implementation of symmetric memory allocation.
\\See Section \ref{subsec:memory_model}.
%
\item Restricted atomic operation guarantees to other atomic operations with the same datatype.
\\See Section \ref{subsec:amo_guarantees}.
%
\item Deprecation of all constants that start with \CONST{\_SHMEM\_*}.
\\See Section \ref{subsec:library_constants}.
%
\item Added a type-generic interface to \openshmem \ac{RMA} and \ac{AMO}
	operations based on \Cstd[11] Generics.
\\See Sections \ref{sec:rma}, \ref{sec:rma_nbi} and \ref{sec:amo}.
%
\item New non-blocking variants of remote memory access, \FUNC{SHMEM\_PUT\_NBI}
	and \FUNC{SHMEM\_GET\_NBI}.
\\See Sections \ref{subsec:shmem_put_nbi} and \ref{subsec:shmem_get_nbi}.
%
\item New atomic elemental read and write operations, \FUNC{SHMEM\_FETCH} and
	\FUNC{SHMEM\_SET}.
\\See Sections \ref{subsec:shmem_atomic_fetch} and \ref{subsec:shmem_atomic_set}
%
\item New alltoall data exchange operations, \FUNC{SHMEM\_ALLTOALL} 
	and \FUNC{SHMEM\_ALLTOALLS}.
\\See Sections \ref{subsec:shmem_alltoall} and \ref{subsec:shmem_alltoalls}.
%
\item Added \CTYPE{volatile} to remotely accessible pointer argument in
	\FUNC{SHMEM\_WAIT} and \FUNC{SHMEM\_LOCK}.
\\See Sections \ref{subsec:shmem_wait} and \ref{subsec:shmem_lock}.
%
\item Deprecation of \FUNC{SHMEM\_CACHE}.
\\See Section \ref{subsec:shmem_cache}.
%
\end{itemize}




\section{Version 1.2}
Major changes in \openshmem[1.2] include
a new initialization routine (\FUNC{shmem\_init}),
improvements to the execution model with the addition of an explicit
library-finalization routine (\FUNC{shmem\_finalize}),
an early-exit routine (\FUNC{shmem\_global\_exit}),
namespace standardization,
and clarifications to several API descriptions.

The following list describes the specific changes in \openshmem[1.2]:
\begin{itemize}
%
\item Added specification of \VAR{pSync} initialization for all routines that use it.
%
\item Replaced all placeholder variable names \VAR{target} with \VAR{dest} to
      avoid confusion with \Fortran `target' keyword.
%
\item New Execution Model for exiting/finishing OpenSHMEM programs.
\\See Section  \ref{subsec:execution_model}.
%
\item New library constants to support API that query version and name information.
\\See Section \ref{subsec:library_constants}.
%
\item New API \FUNC{shmem\_init} to provide mechanism to start an \openshmem
      program and replace deprecated \FUNC{start\_pes}.
\\See Section \ref{subsec:shmem_init}.
%
\item Deprecation of \FUNC{\_my\_pe} and \FUNC{\_num\_pes} routines.
\\See Sections \ref{subsec:shmem_my_pe} and \ref{subsec:shmem_n_pes}.
%
\item New API \FUNC{shmem\_finalize} to provide collective mechanism to cleanly
      exit an \openshmem program and release resources.
\\See Section \ref{subsec:shmem_finalize}.
%
\item New API \FUNC{shmem\_global\_exit} to provide mechanism to exit an
    \openshmem program.
\\See Section \ref{subsec:shmem_global_exit}.
%
\item Clarification related to the address of the referenced object in
    \FUNC{shmem\_ptr}.
\\See Section \ref{subsec:shmem_ptr}.
%
\item New API to query the version and name information. 
\\See Section \ref{subsec:shmem_info_get_version} and \ref{subsec:shmem_info_get_name}.
%
\item \openshmem library API normalization. All \Cstd symmetric memory management
      API begins with  \FUNC{shmem\_}.
\\See Section \ref{subsec:shfree}.
%
\item Notes and clarifications added to \FUNC{shmem\_malloc}.
\\See Section \ref{subsec:shfree}.
%
\item Deprecation of \Fortran API routine \FUNC{SHMEM\_PUT}.
\\See Section \ref{subsec:shmem_put}. 
%
\item Clarification related to \FUNC{shmem\_wait}.
\\See Section \ref{subsec:shmem_wait}.
%
\item Undefined behavior for null pointers without zero counts added.
\\See Annex \ref{sec:undefined}
%
\item Addition of new Annex for clearly specifying deprecated API and its
      support in the existing specification version.
\\See Annex \ref{sec:dep_api}.
%
\end{itemize}




\section{Version 1.1}
Major changes from \openshmem[1.0] to \openshmem[1.1] include
the introduction of the \HEADER{shmemx.h} header file for non-standard API
extensions,
clarifications to completion semantics and API descriptions in agreement with
the \ac{SGI} SHMEM specification,
and general readabilty and usability improvements to the document structure.

The following list describes the specific changes in \openshmem[1.1]:
\begin{itemize}
%
\item Clarifications of the completion semantics of memory synchronization 
      interfaces.
\\See Section \ref{subsec:memory_order}.
%
\item Clarification of the completion semantics of memory load and store
      operations in context of \FUNC{shmem\_barrier\_all} and \FUNC{shmem\_barrier}
      routines.
\\See Section \ref{subsec:shmem_barrier_all} and \ref{subsec:shmem_barrier}.
%
\item Clarification of the completion and ordering semantics of
      \FUNC{shmem\_quiet} and \FUNC{shmem\_fence}.
\\See Section \ref{subsec:shmem_quiet} and \ref{subsec:shmem_fence}.
%
\item Clarifications of the completion semantics of \ac{RMA} and \ac{AMO}
      routines.
\\See Sections \ref{sec:rma} and \ref{sec:amo}
%
\item Clarifications of the memory model and the memory alignment requirements
      for symmetric data objects.
\\See Section \ref{subsec:memory_model}.
%
\item Clarification of the execution model and the definition of a \ac{PE}.
\\See Section \ref{subsec:execution_model}
%
\item Clarifications of the semantics of \FUNC{shmem\_pe\_accessible} and
      \FUNC{shmem\_addr\_accessible}.
\\See Section \ref{subsec:shmem_pe_accessible} and \ref{subsec:shmem_addr_accessible}.
%
\item Added an annex on interoperability with \ac{MPI}.
\\See Annex \ref{sec:mpi}.
%
\item Added examples to the different interfaces.
%
\item Clarification of the naming conventions for constant in \Cstd and
      \Fortran.
\\See Section \ref{subsec:library_constants} and \ref{subsec:shmem_wait}.
%
\item Added \ac{API} calls: \FUNC{shmem\_char\_p}, \FUNC{shmem\_char\_g}.
\\See Sections \ref{subsec:shmem_p} and \ref{subsec:shmem_g}. 
%
\item Removed \ac{API} calls: \FUNC{shmem\_char\_put},
      \FUNC{shmem\_char\_get}.
\\See Sections \ref{subsec:shmem_put} and \ref{subsec:shmem_get}. 
%
\item The usage of \CTYPE{ptrdiff\_t}, \CTYPE{size\_t}, and \CTYPE{int} in the
      interface signature was made consistent with the description.
\\See Sections \ref{subsec:coll}, \ref{subsec:shmem_iput}, and \ref{subsec:shmem_iget}.
%
\item Revised \FUNC{shmem\_barrier} example.
\\See Section \ref{subsec:shmem_barrier}. 
%
\item Clarification of the initial value of \VAR{pSync} work arrays for
\FUNC{shmem\_barrier}.\\ See Section \ref{subsec:shmem_barrier}. 
%
\item Clarification of the expected behavior when multiple \FUNC{start\_pes}
calls are encountered.
\\See Section \ref{subsec:start_pes}.
%
\item Corrected the definition of atomic increment operation.
\\See Section \ref{subsec:shmem_atomic_inc}.
%
\item Clarification of the size of the symmetric heap and when it is set.
\\See Section \ref{subsec:shfree}.
%
\item Clarification of the integer and real sizes for \Fortran \ac{API}.
\\See Sections \ref{subsec:shmem_atomic_add},
      \ref{subsec:shmem_atomic_compare_swap},
      \ref{subsec:shmem_atomic_swap},
      \ref{subsec:shmem_atomic_fetch_inc},
      \ref{subsec:shmem_atomic_inc}, and
      \ref{subsec:shmem_atomic_fetch_add}.
%
\item Clarification of the expected behavior on program \OPR{exit}.
\\See Section \ref{subsec:execution_model}, Execution Model. 
%
\item More detailed description for the progress of \openshmem operations
provided.
\\See Section \ref{subsec:progress}. 
%
\item Clarification of naming convention for non-standard interfaces and their
inclusion in \HEADER{shmemx.h}.
\\See Section \ref{subsec:bindings}. 
%
\item Various fixes to \openshmem code examples across the specification to
include appropriate header files. 
%
\item Removing requirement that implementations should detect size mismatch and
return error information for \FUNC{shmalloc} and ensuring consistent
language.
\\See Sections \ref{subsec:shfree} and Annex \ref{sec:undefined}. 
%
\item \Fortran programming fixes for examples.\\ See Sections
\ref{subsec:shmem_reductions} and \ref{subsec:shmem_wait}. 
%
\item Clarifications of the reuse \VAR{pSync} and \VAR{pWork} across
collectives.
\\See Sections \ref{subsec:coll}, \ref{subsec:shmem_broadcast},
      \ref{subsec:shmem_collect} and \ref{subsec:shmem_reductions}.
%
\item Name changes for UV and ICE for \ac{SGI} systems.
\\See Annex \ref{sec:openshmem_history}. 
%
\end{itemize}




} %end of setlength command that was started in frontmatter.tex
