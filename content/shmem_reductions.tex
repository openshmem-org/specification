\apisummary{
    The following functions perform reduction operations across all
    \acp{PE} in a set of \acp{PE}.
}

\begin{apidefinition}

\paragraph{AND}
Performs a bitwise AND reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_and\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer types supported for the AND operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}
\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_and\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_and\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer types supported for the AND operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{OR}
Performs a bitwise OR reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_or\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer types supported for the OR operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}
\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_or\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_or\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer types supported for the OR operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{XOR}
Performs a bitwise exclusive OR (XOR) reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_xor\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer types supported for the XOR operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}
\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_xor\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_xor\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer types supported for the XOR operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{MAX}
Performs a maximum-value reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_max\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer or real types supported for the MAX operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}

\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_max\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_max\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer or real types supported for the MAX operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{MIN}
Performs a minimum-value reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_min\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer or real types supported for the MIN operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}

\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_min\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_min\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer or real types supported for the MIN operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{SUM}
Performs a sum reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_sum\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer, real, or complex types supported for the SUM operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}

\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_sum\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_sum\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer, real, or complex types supported for the SUM operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\paragraph{PROD}
Performs a product reduction across a set of \acp{PE}.\newline

%% C11
\begin{C11synopsis}
int @\FuncDecl{shmem\_prod\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{C11synopsis}
where \TYPE{} is one of the integer, real, or complex types supported for the PROD operation as specified by Table \ref{teamreducetypes}.

%% C/C++
\begin{Csynopsis}
\end{Csynopsis}

\begin{CsynopsisCol}
int @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_prod\_reduce}@(shmem_team_t team, TYPE *dest, const TYPE *source, size_t nreduce);
\end{CsynopsisCol}

\begin{DeprecateBlock}
\begin{CsynopsisCol}
void @\FuncDecl{shmem\_\FuncParam{TYPENAME}\_prod\_to\_all}@(TYPE *dest, const TYPE *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
\end{CsynopsisCol}
\end{DeprecateBlock}
where \TYPE{} is one of the integer, real, or complex types supported for the PROD operation and has a corresponding \TYPENAME{} as specified by Table \ref{asetreducetypes}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|l|l|l|l|l|}
      \hline
      \TYPE              & \TYPENAME  & \multicolumn{3}{c|}{Operations Supporting \TYPE}\\ \hline
      char               & char       &              & MAX, MIN & SUM, PROD \\ \hline
      signed char        & schar      &              & MAX, MIN & SUM, PROD \\ \hline
      short              & short      &              & MAX, MIN & SUM, PROD \\ \hline
      int                & int        &              & MAX, MIN & SUM, PROD \\ \hline
      long               & long       &              & MAX, MIN & SUM, PROD \\ \hline
      long long          & longlong   &              & MAX, MIN & SUM, PROD \\ \hline
      ptrdiff\_t         & ptrdiff    &              & MAX, MIN & SUM, PROD \\ \hline
      unsigned char      & uchar      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      unsigned short     & ushort     & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      unsigned int       & uint       & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      unsigned long      & ulong      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      unsigned long long & ulonglong  & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      int8\_t            & int8       & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      int16\_t           & int16      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      int32\_t           & int32      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      int64\_t           & int64      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      uint8\_t           & uint8      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      uint16\_t          & uint16     & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      uint32\_t          & uint32     & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      uint64\_t          & uint64     & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      size\_t            & size       & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      float              & float      &              & MAX, MIN & SUM, PROD \\ \hline
      double             & double     &              & MAX, MIN & SUM, PROD \\ \hline
      long double        & longdouble &              & MAX, MIN & SUM, PROD \\ \hline
      double \_Complex   & complexd   &              &          & SUM, PROD \\ \hline
      float  \_Complex   & complexf   &              &          & SUM, PROD \\ \hline
    \end{tabular}
    \TableCaptionRef{Reduction Types, Names, and Supporting Operations for Team-Based Reductions}
    \label{teamreducetypes}
  \end{center}
\end{table}

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|l|l|l|l|l|}
      \hline
      \TYPE              & \TYPENAME  & \multicolumn{3}{c|}{Operations Supporting \TYPE}\\ \hline
      short              & short      & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      int                & int        & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      long               & long       & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      long long          & longlong   & AND, OR, XOR & MAX, MIN & SUM, PROD \\ \hline
      float              & float      &              & MAX, MIN & SUM, PROD \\ \hline
      double             & double     &              & MAX, MIN & SUM, PROD \\ \hline
      long double        & longdouble &              & MAX, MIN & SUM, PROD \\ \hline
      double \_Complex   & complexd   &              &          & SUM, PROD \\ \hline
      float  \_Complex   & complexf   &              &          & SUM, PROD \\ \hline
    \end{tabular}
    \TableCaptionRef{Reduction Types, Names and Supporting Operations for Active-Set-Based Reductions}
    \label{asetreducetypes}
  \end{center}
\end{table}

\begin{apiarguments}

\apiargument{IN}{team}{The team over which to perform the operation.}%

\apiargument{OUT}{dest}{Symmetric address of an array, of length \VAR{nreduce} elements, to
    receive the result of the reduction routines.
    The type of \dest{} should match that implied in the SYNOPSIS section.}
\apiargument{IN}{source}{Symmetric address of an array, of length \VAR{nreduce} elements, that
    contains one element for each separate reduction routine.
    The type of \source{} should match that implied in the SYNOPSIS section.}
\apiargument{IN}{nreduce}{The number of elements in the \dest{} and \source{}
    arrays. In teams based API calls, \VAR{nreduce} must be of type size\_t.
    In deprecated active-set based API calls,
    \VAR{nreduce} must be of type integer.}

\begin{DeprecateBlock}
\apiargument{IN}{PE\_start}{The lowest \ac{PE} number of the active set of
    \acp{PE}.}
\apiargument{IN}{logPE\_stride}{The log (base 2) of the stride between consecutive
    \ac{PE} numbers in the active set.}
    \apiargument{IN}{PE\_size}{The number of \acp{PE} in the active set.}
\apiargument{IN}{pWrk}{
    Symmetric address of a work array of size at least
    max(\VAR{nreduce}/2 + 1, \CONST{SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE})
    elements.}
\apiargument{IN}{pSync}{
    Symmetric address of a work array of size at least \CONST{SHMEM\_REDUCE\_SYNC\_SIZE}.}
\end{DeprecateBlock}

\end{apiarguments}

\apidescription{
    \openshmem reduction routines are collective routines over an active set or
    existing \openshmem team that compute one or more reductions across symmetric
    arrays on multiple \acp{PE}.  A reduction performs an associative binary routine
    across a set of values.

    The \VAR{nreduce} argument determines the number of separate reductions to
    perform.  The \source{} array on all \acp{PE} participating in the reduction
    provides one element for each reduction.  The results of the reductions are placed in the
    \dest{} array on all \acp{PE} participating in the reduction.

    The \source{} and \dest{} arguments must either be the same symmetric
    address, or two different symmetric addresses corresponding to buffers that
    do not overlap in memory. That is, they must be completely overlapping or
    completely disjoint.

    Team-based reduction routines operate over all \acp{PE} in the provided team argument. All
    \acp{PE} in the provided team must participate in the reduction. If an invalid team handle
    or \LibConstRef{SHMEM\_TEAM\_INVALID} is passed to this routine, the behavior is undefined.

    Active-set-based sync routines operate over all \acp{PE} in the active set
    defined by the \VAR{PE\_start}, \VAR{logPE\_stride}, \VAR{PE\_size} triplet.

    As with all active set-based collective routines,
    each of these routines assumes
    that only \acp{PE} in the active set call the routine.  If a \ac{PE} not in
    the active set calls an active set-based collective routine,
    the behavior is undefined.

    The values of arguments \VAR{nreduce}, \VAR{PE\_start}, \VAR{logPE\_stride},
    and \VAR{PE\_size} must be equal on all \acp{PE} in the active set.
    The same \VAR{pWrk} and \VAR{pSync} work arrays must be passed to all
    \acp{PE} in the active set.

    Before any \ac{PE} calls a reduction routine, the following conditions must be ensured:
    \begin{itemize}
    \item The \dest{} array on all \acp{PE} participating in the reduction
      is ready to accept the results of the \OPR{reduction}.
    \item If using active-set-based routines, the
      \VAR{pWrk} and \VAR{pSync} arrays on all \acp{PE} in the
      active set are not still in use from a prior call to a collective
      \openshmem routine.
    \end{itemize}
    Otherwise, the behavior is undefined.
    
    Upon return from a reduction routine, the following are true for the local
    \ac{PE}:
    \begin{itemize}
    \item The \dest{} array is updated and the \source{} array may be safely reused.
    \item If using active-set-based routines,
    the values in the \VAR{pSync} array are restored to the original values.
    \end{itemize}

    The complex-typed interfaces are only provided for sum and product reductions.
    When the \Cstd translation environment does not support complex types
    \footnote{That is, under \Cstd language standards prior to \Cstd[99] or under \Cstd[11]
    when \CONST{\_\_STDC\_NO\_COMPLEX\_\_} is defined to 1}, an \openshmem
    implementation is not required to provide support for these
    complex-typed interfaces.
}

\apireturnvalues{
  Zero on successful local completion. Nonzero otherwise.
}

\apinotes{
  % TODO: Remove me!
  None.
}

\begin{apiexamples}

\apicexample
    {This \Cstd[11] reduction example gets integers from an external
    source (random generator in this example), tests to see if the \ac{PE} got a valid
    value, and outputs the sum of values for which all \acp{PE} got a valid
    value.}
    {./example_code/shmem_reduce_example.c}
    {}

\end{apiexamples}

\end{apidefinition}
