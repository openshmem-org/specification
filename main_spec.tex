\documentclass[10pt]{book}

\input{utils/packages}

\input{utils/defs}

\begin{document}

\input{content/frontmatter}



\section{The OpenSHMEM Effort}\label{subsec:openshmem_effort}
\input{content/the_openshmem_effort}

\section{Programming Model Overview}\label{subsec:programming_model}
\input{content/programming_model_overview}

\section{Memory Model}\label{subsec:memory_model}
\input{content/memory_model}

\section{Execution Model}\label{subsec:execution_model}
\input{content/execution_model}

\section{Language Bindings and Conformance}\label{subsec:bindings}
\input{content/language_bindings_and_conformance}

\section{Library Constants}\label{subsec:library_constants}
\input{content/library_constants}

\section{Library Handles}\label{subsec:library_handles}
\input{content/library_handles}

\section{Environment Variables }\label{subsec:environment_variables}
\input{content/environment_variables}




\clearpage



\section{OpenSHMEM Library API}\label{sec:openshmem_library_api}

\subsection{Library Setup, Exit, and Query Routines}
The library setup and query interfaces that initialize and monitor the parallel
environment of the \acp{PE}.

\subsubsection{\textbf{SHMEM\_INIT}}\label{subsec:shmem_init}
\input{content/shmem_init}

\subsubsection{\textbf{SHMEM\_MY\_PE}}\label{subsec:shmem_my_pe}
\input{content/shmem_my_pe}

\subsubsection{\textbf{SHMEM\_N\_PES}}\label{subsec:shmem_n_pes}
\input{content/shmem_n_pes}

\subsubsection{\textbf{SHMEM\_FINALIZE}}\label{subsec:shmem_finalize}
\input{content/shmem_finalize}

\subsubsection{\textbf{SHMEM\_GLOBAL\_EXIT}}\label{subsec:shmem_global_exit}
\input{content/shmem_global_exit}

\subsubsection{\textbf{SHMEM\_PE\_ACCESSIBLE}}\label{subsec:shmem_pe_accessible}
\input{content/shmem_pe_accessible}

\subsubsection{\textbf{SHMEM\_ADDR\_ACCESSIBLE}}\label{subsec:shmem_addr_accessible}
\input{content/shmem_addr_accessible}

\subsubsection{\textbf{SHMEM\_PTR}}\label{subsec:shmem_ptr}
\input{content/shmem_ptr}

\subsubsection{\textbf{SHMEM\_INFO\_GET\_VERSION}}\label{subsec:shmem_info_get_version}
\input{content/shmem_info_get_version}

\subsubsection{\textbf{SHMEM\_INFO\_GET\_NAME}}\label{subsec:shmem_info_get_name}
\input{content/shmem_info_get_name}

\subsubsection{\textbf{START\_PES}}\label{subsec:start_pes}
\input{content/start_pes}

\subsection{Thread Support}
\label{subsec:thread_support}
\input{content/threads_intro.tex}

\subsubsection{\textbf{SHMEM\_INIT\_THREAD}}
\label{subsec:shmem_init_thread}
\input{content/shmem_init_thread}

\subsubsection{\textbf{SHMEM\_QUERY\_THREAD}}
\label{subsec:shmem_query_thread}
\input{content/shmem_query_thread}


\subsection{Memory Management Routines}
\label{sec:memory_management}

\openshmem provides a set of \acp{API} for managing the symmetric heap. The
\acp{API} allow one to dynamically allocate, deallocate, reallocate and align
symmetric data objects in the symmetric heap.

\subsubsection{\textbf{SHMEM\_MALLOC, SHMEM\_FREE, SHMEM\_REALLOC, SHMEM\_ALIGN}}\label{subsec:shfree}
\input{content/shmem_malloc.tex}

\subsubsection{\textbf{SHMEM\_CALLOC}}\label{subsec:shmem_calloc}
\input{content/shmem_calloc.tex}

\subsubsection{\textbf{SHPALLOC}}\label{subsec:shpalloc}
\input{content/shpalloc.tex}

\subsubsection{\textbf{SHPCLMOVE}}\label{subsec:shpclmove}
\input{content/shpclmove.tex}

\subsubsection{\textbf{SHPDEALLC}}\label{subsec:shpdeallc}
\input{content/shpdeallc.tex}




\color{Green}
\subsection{Teams Management Routines}\label{subsec:team}

The \acp{PE} in an \openshmem program can communicate either using
point-to-point routines that specify the \ac{PE} number of the target
\ac{PE} or using collective routines which operate over some predefined
set of \acp{PE}. Teams in \openshmem allow programs to group subsets
of \acp{PE} for collective communications and provide a contiguous renumbering
of the \acp{PE} within that subset that can be used in point-to-point communication.

An \openshmem team is a set of \acp{PE} defined by calling a specific team
split routine with a parent team argument and other arguments to further
specify how the parent team is to be split into one more new teams.
A team created by a team split routine can be used as the parent team
for a subsequent call to a team split routine.  A team persists and can
be used for multiple collective routine calls until it is destroyed by
\FUNC{shmem\_team\_destroy}.

Every team must have a least one member. Any attempt to create a team over an empty set of \acp{PE} will result in no new team being created.

A "team handle" is an opaque object with type \CTYPE{shmem\_team\_t} that is used
to reference a defined team.  Team handles are created by one of the team split
routines and destroyed by the team destroy routine. Team handles have local
semantics only. That is, team handles should not be stored in shared variables
and used across other \acp{PE}. Doing so will result in undefined behavior.

By default, \openshmem creates predefined teams that will be available
for use once the routine \FUNC{shmem\_init} has been called. See section
\ref{subsec:library_handles} for a description of all predefined team handles
provided by \openshmem. Predefined \CTYPE{shmem\_team\_t} handles can be used as
the parent team when creating new \openshmem teams.

Every \ac{PE} is a member of the \LibHandleRef{SHMEM\_TEAM\_WORLD} team,
and its number in \LibHandleRef{SHMEM\_TEAM\_WORLD} corresponds to the
value of its global \ac{PE} number as returned by \FUNC{shmem\_my\_pe}.

A special team handle value, \LibConstRef{SHMEM\_TEAM\_NULL}, is used to
indicate that a returned team handle is not valid. This value can be tested
against to check for successful split operations and can be assigned to user
declared team handles as a sentinel value.

Teams may be created with options that change team behavior and may allow for
more optimized performance. These options are described in section
\ref{subsec:library_constants} and in the various descriptions of the
team split routines below. In particular, teams may be created with an option
to disable support for collective communications, which allows implementations
to reduce team creation overheads for those teams. In that case, the team is 
just a local renumbering of some set of \acp{PE} that can be used for
point to point communications or as parent teams in subsequent split operations.

\subsubsection{\textbf{SHMEM\_TEAM\_MY\_PE}}\label{subsec:shmem_team_my_pe}
\input{content/shmem_team_my_pe.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_N\_PES}}\label{subsec:shmem_team_n_pes}
\input{content/shmem_team_n_pes.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_GET\_OPTIONS}}\label{subsec:shmem_team_get_options}
\input{content/shmem_team_get_options.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_TRANSLATE}}\label{subsec:shmem_team_translate}
\input{content/shmem_team_translate.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_SPLIT\_STRIDED}}\label{subsec:shmem_team_split_strided}
\input{content/shmem_team_split_strided.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_SPLIT\_3D}}\label{subsec:shmem_team_split_3d}
\input{content/shmem_team_split_3d.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_DESTROY}}\label{subsec:shmem_team_destroy}
\input{content/shmem_team_destroy.tex}
\color{Black}




\subsection{Communication Management Routines}
\label{sec:ctx}
All \openshmem RMA, AMO, and memory ordering routines are
performed on a communication context.  The communication context defines an
independent ordering and completion environment, allowing users to manage the
overlap of communication with computation and also to manage communication
operations performed by separate threads within a multithreaded \ac{PE}.  For
example, in single-threaded environments, contexts may be used to pipeline
communication and computation.  In multithreaded environments, contexts may
additionally provide thread isolation, eliminating overheads resulting from
thread interference.

Context handles are of type \CTYPE{shmem\_ctx\_t} and are valid for
language-level assignment and equality comparison.  A handle to the desired context is
passed as an argument in the \Cstd \CTYPE{shmem\_ctx\_*} and type-generic API
routines.  API routines that do not accept a context argument operate on the
default context.  The default context can be used explicitly through the
\LibHandleRef{SHMEM\_CTX\_DEFAULT} handle.

\newtext{
Every communication context has an associated \ac{PE} team.
This \ac{PE} team specifies the set of \acp{PE} over which \ac{PE}-specific
routines that operate on a communication context, explicitly or implicitly,
(e.g., \ac{RMA} and \ac{AMO} routines) may be performed.
All \openshmem routines that operate on this context will do so with respect
to the team-relative \ac{PE} numbering of the associated \ac{PE} team.
}

\newtext{
The default context has a fixed association with the default team.
Communication contexts created by \FUNC{shmem\_ctx\_create} have an initial
association with the default team, which may be updated by the
\FUNC{shmem\_ctx\_set\_team} routine.
}

\subsubsection{\textbf{SHMEM\_CTX\_CREATE}}
\label{subsec:shmem_ctx_create}
\input{content/shmem_ctx_create.tex}

\subsubsection{\textbf{SHMEM\_CTX\_DESTROY}}
\label{subsec:shmem_ctx_destroy}
\input{content/shmem_ctx_destroy.tex}

\newtext{
\subsubsection{\textbf{SHMEM\_CTX\_SET\_TEAM}}
\label{subsec:shmem_ctx_set_team}
\input{content/shmem_ctx_set_team.tex}
}

\newtext{
\subsubsection{\textbf{SHMEM\_CTX\_GET\_TEAM}}
\label{subsec:shmem_ctx_get_team}
\input{content/shmem_ctx_get_team.tex}
}


\subsection{Remote Memory Access Routines}\label{sec:rma}
\input{content/rma_intro.tex}

\subsubsection{\textbf{SHMEM\_PUT}}\label{subsec:shmem_put}
\input{content/shmem_put.tex}

\subsubsection{\textbf{SHMEM\_P}}\label{subsec:shmem_p}
\input{content/shmem_p.tex}

\subsubsection{\textbf{SHMEM\_IPUT}}\label{subsec:shmem_iput}
\input{content/shmem_iput.tex}

\subsubsection{\textbf{SHMEM\_GET}}\label{subsec:shmem_get}
\input{content/shmem_get.tex}

\subsubsection{\textbf{SHMEM\_G}}\label{subsec:shmem_g}
\input{content/shmem_g.tex}

\subsubsection{\textbf{SHMEM\_IGET}}\label{subsec:shmem_iget}
\input{content/shmem_iget.tex}


\subsection{Non-blocking Remote Memory Access Routines}\label{sec:rma_nbi}

\subsubsection{\textbf{SHMEM\_PUT\_NBI}}\label{subsec:shmem_put_nbi}
\input{content/shmem_put_nbi.tex}

\subsubsection{\textbf{SHMEM\_GET\_NBI}}\label{subsec:shmem_get_nbi}
\input{content/shmem_get_nbi.tex}


\subsection{Atomic Memory Operations}\label{sec:amo}
\input{content/atomics_intro}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH}}
\label{subsec:shmem_atomic_fetch}
\input{content/shmem_atomic_fetch.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_SET}}
\label{subsec:shmem_atomic_set}
\input{content/shmem_atomic_set.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_COMPARE\_SWAP}}
\label{subsec:shmem_atomic_compare_swap}
\input{content/shmem_atomic_compare_swap.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_SWAP}}
\label{subsec:shmem_atomic_swap}
\input{content/shmem_atomic_swap.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH\_INC}}
\label{subsec:shmem_atomic_fetch_inc}
\input{content/shmem_atomic_fetch_inc.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_INC}}
\label{subsec:shmem_atomic_inc}
\input{content/shmem_atomic_inc.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH\_ADD}}
\label{subsec:shmem_atomic_fetch_add}
\input{content/shmem_atomic_fetch_add.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_ADD}}
\label{subsec:shmem_atomic_add}
\input{content/shmem_atomic_add.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH\_AND}}
\label{subsec:shmem_atomic_fetch_and}
\input{content/shmem_atomic_fetch_and.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_AND}}
\label{subsec:shmem_atomic_and}
\input{content/shmem_atomic_and.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH\_OR}}
\label{subsec:shmem_atomic_fetch_or}
\input{content/shmem_atomic_fetch_or.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_OR}}
\label{subsec:shmem_atomic_or}
\input{content/shmem_atomic_or.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_FETCH\_XOR}}
\label{subsec:shmem_atomic_fetch_xor}
\input{content/shmem_atomic_fetch_xor.tex}

\subsubsection{\textbf{SHMEM\_ATOMIC\_XOR}}
\label{subsec:shmem_atomic_xor}
\input{content/shmem_atomic_xor.tex}





\subsection{Collective Routines}\label{subsec:coll}
\input{content/collective_intro.tex}

\subsubsection{\textbf{SHMEM\_BARRIER\_ALL}}\label{subsec:shmem_barrier_all}
\input{content/shmem_barrier_all.tex}

\subsubsection{\textbf{SHMEM\_BARRIER}}\label{subsec:shmem_barrier}
\input{content/shmem_barrier.tex}

\subsubsection{\textbf{SHMEM\_SYNC\_ALL}}\label{subsec:shmem_sync_all}
\input{content/shmem_sync_all.tex}

\subsubsection{\textbf{SHMEM\_SYNC}}\label{subsec:shmem_sync}
\input{content/shmem_sync.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_BROADCAST}}\label{subsec:shmem_team_broadcast}
\input{content/shmem_team_broadcast.tex}

\subsubsection{\textbf{SHMEM\_BROADCAST}}\label{subsec:shmem_broadcast}
\input{content/shmem_broadcast.tex}

\subsubsection{\textbf{SHMEM\_COLLECT, SHMEM\_FCOLLECT}}\label{subsec:shmem_collect}
\input{content/shmem_collect.tex}

\subsubsection{\textbf{SHMEM\_TEAM\_COLLECT, SHMEM\_TEAM\_FCOLLECT}}\label{subsec:shmem_team_collect}
\input{content/shmem_team_collect.tex}

\subsubsection{\textbf{SHMEM\_REDUCTIONS}}\label{subsec:shmem_reductions}
\input{content/shmem_reductions.tex}

\subsubsection{\textbf{SHMEM\_ALLTOALL}}\label{subsec:shmem_alltoall}
\input{content/shmem_alltoall.tex}

\subsubsection{\textbf{SHMEM\_ALLTOALLS}}\label{subsec:shmem_alltoalls}
\input{content/shmem_alltoalls.tex}




\subsection{Point-To-Point Synchronization Routines}\label{subsec:p2p_intro}
\input{content/p2p_sync_intro.tex}

\subsubsection{\textbf{SHMEM\_WAIT\_UNTIL}}\label{subsec:shmem_wait_until}
\input{content/shmem_wait_until.tex}

\subsubsection{\textbf{SHMEM\_TEST}}\label{subsec:shmem_test}
\input{content/shmem_test.tex}





\subsection{Memory Ordering Routines}\label{subsec:memory_order}
The following section discusses \openshmem \acp{API} that provide mechanisms to
ensure ordering and/or delivery of \OPR{Put}, \ac{AMO}, memory store,
and non-blocking \PUT{} and \GET{} routines to symmetric data objects.

\subsubsection{\textbf{SHMEM\_FENCE}}\label{subsec:shmem_fence}
\input{content/shmem_fence.tex}

\subsubsection{\textbf{SHMEM\_QUIET}}\label{subsec:shmem_quiet}
\input{content/shmem_quiet.tex}

\subsubsection{Synchronization and Communication Ordering in OpenSHMEM}
\input{content/synchronization_model.tex}






\subsection{Distributed Locking Routines}
The following section discusses \openshmem locks as a mechanism to provide
mutual exclusion. Three routines are available for distributed locking,
\textit{set, test} and \textit{clear}.

\subsubsection{\textbf{SHMEM\_LOCK}}\label{subsec:shmem_lock}
\input{content/shmem_lock.tex}





\subsection{Cache Management}
All of these routines are deprecated and are provided for backwards
compatibility.  Implementations must include all items in this section, and the
routines should function properly and may notify the user about deprecation of
their use.

\subsubsection{\textbf{SHMEM\_CACHE}}\label{subsec:shmem_cache}
\input{content/shmem_cache.tex}

\clearpage
\input{content/backmatter}

\clearpage
\phantomsection
\addcontentsline{toc}{chapter}{Index}
\printindex

\end{document}

