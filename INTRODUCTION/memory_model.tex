%Outline
%%Exectution model
%   *Define what is a OpenSHMEM program: a set of processes (either SPMD or MIMD?) where each process has its own 'local' (private) memory and symmetric memory regions that may be accessible by any PEs.
%   *Each OpenSHMEM process is called a processing element (PE)
%   *Each PE may be mapped to many to one hardware cores/threads or less.
%   *The number of PEs is specified at launch/runtime.
%   *Each PE must call startpe to initialize the OpenSHMEM runtime, before any other call for OpenSHMEM. There is an implicit barrier at startpe.
%   *Each PE executes asynchronously following Fortran or program execution in C [ISO/IEC00 Sec. 5.1.2.3]
%   *Each PE will have a unique global identifier and the execution of a program may depend on the PE id, if executed in SPMD.
%   *PE id may be used for library calls synchronizations, control flow constructs language  in C/Fortran
%   *PE may allocate symmetric data objects via a symmetric heap 
%   *As of now, PEs may finish execution at any time by returning from the main function. (no call to shmem_finalize yet!)
%   
%  %Memory model
%    *Each OpenSHMEM PEs may have symmetric memory that is accessible by other PEs. 
%    *Symmetric memory is a region of memory where all the an instance of a data objects is replicated across PEs, have 
%     the same the same layout and relative offset.
%    *All PEs can allocate a symmetric data objects using the symmetric heap, but they must do so as a collective operation. (is there a barrier after shmalloc?)
%    *All writes to symmetric memory are relaxed (I'm not sure if this is the completion semantics) and are guaranteed to be visible to other PEs after a barrier_all, barrier(?), quiet, (what about wait? does it means iti sonly visible to me?) 
%    *Calls to barrier, barrier_all, quiet, wait, lock, atomics, are meant to guarantee memory consistency across PEs.
%    *Read/Writes to symmetic data object may appear after startpe or after a the symmetric data object has been allocated in the symmetric heap (if it is a dynamic).
%    *Operations like reduction, collect, etc guarantee memory consistency after completion(?)
%    *Data races are possible in OpenSHMEM if multiple PEs write/read a symmetric data object from a single PE without proper synchronization.  
%
%This comes from the UPC spec:
%The memory consistency model in a language defines the order in which the results of write operations may be observed through read operations.
%The behavior of a OpenSHMEM program may depend on the timing of accesses to symetric variables on PEs, so in general a program defines a set of possible executions, 
%rather than a single execution. The memory consistency model constrains the set of possible executions for a given program; the user may then rely 
%on properties that are true of all of those executions.

\section{Memory Model}

In \openshmem{} each \ac{PE } has access to its own local private memory (\textbf{not} accessible to other PEs) and  a remotely accessible symmetric memory that 
can be read by or written to by all\ac{PE}s. Data objects accessible by all the \ac{PE}s are defined as symmetric objects.
A  symmetric data object can be any object stored in the global or static sections of the code as defined by the memory model of ~\Clang{} or ~\Fortran (\emph{e.g.} in the ELF executable format), or allocated in a symmetric heap.  All instances of the same symmetric object have the same \textit{relative memory offset}, size and type on all \ac{PE}s. 
%Consistent with the SPMD nature of the \openshmem programming model  is  the concept of symmetric data objects.  These are arrays or variables that exist with the same size,  type,	 and  relative	address	 on  all  PEs.
Another term  for  symmetric data objects is "remotely accessible data objects."  The following kinds of data objects are symmetric:
\begin{itemize}
  \item Fortran data objects in common blocks or with the  SAVE  attribute. These data objects	must not be defined in a dynamic shared object (DSO).
  \item Non-stack C and C++ variables.   These  data	objects must  not  be defined in a DSO.
  \item Fortran arrays allocated with \textit{shpalloc} 
  \item C and C++ data allocated by \textit{shmalloc}
\end{itemize}       

In \openshmem, access to symmetric objects is done via one-sided put (for write) and gets (for read) calls as well as various collective
calls such as broadcasts and reductions.  At least one of the the parameters (target or source) of these calls is required to be symmetric or remotely accessible. 

All \ac{PE}s may allocate symmetric data objects on the symmetric heap, but they must do so as a collective operation. 
The memory region of the symmetric heap, which is created by all \ac{PE}s during the program initialization is implementation dependent and 
may be different on all the \ac{PE}s. \openshmem has nothing
to say regarding the underlying memory layout; it is up to the implementation
to decide how to implement the symmetric heap. Private data objects in \openshmem are stored in the local memory of each \ac{PE} 
and follow the memory model of \Clang{} or \Fortran{}. Objects that reside in the private address space can only be accessed by the PE itself; these data objects
cannot be accessed by other PEs via \openshmem{} routines. 



%\begin{figure}[H]
%\noindent \begin{centering}
%\includegraphics{media/symmetric_heap}
%\par\end{centering}
%
%\caption{{\small Example of Symmetric Objects}\label{fig:SymmetricHeap1}}
%\end{figure}

