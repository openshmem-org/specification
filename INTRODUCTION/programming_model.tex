\section{Programming Model Overview}
%SP: Addressing suggestions from discussion on 01/28/2014 Merging the commented portions into the body. 
%The \openshmem programming model consists of library functions that provide
%low-latency, high-bandwidth communication  for  use  in  highly  parallelized 
%scalable programs. The functions in the \openshmem \ac{API} provide a programming 
%model for exchanging data between cooperating parallel processes. The resulting programs are similar 
%in style to \ac{MPI} programs. The \openshmem \ac{API} can be used either alone 
%or in combination with \ac{MPI} functions in the same parallel program.

\openshmem implements a \ac{PGAS} model. In the \ac{PGAS} model, each process has a local and 
globally shared memory where portions of the shared memory may have affinity to a particular process. 
\openshmem implements \ac{PGAS} by defining symmetric data objects as a mechanism to share information among \openshmem processes or \ac{PE}. 
The \openshmem library functions provide low-latency, high-bandwidth communication \ac{API} for  use  in  highly  parallelized 
scalable programs. The \ac{API} allows communication and synchronization operations on both local and symmetric data objects. 
\openshmem is a library and unlike UPC, CAF, Titanium, X10 and Chapel, which are all
PGAS languages, it relies on the programmer to use the library calls correctly to implement the semantics of its programming model.
\rcomment{Manju: To do - Make sure the first paragraph does not say the same
things has first paragraph of Section 1}

An \openshmem program is currently \ac{SPMD} in style. The
\openshmem  processes, called \ac{PE}s, all start at the
same time, and they all run the same program. Usually the \ac{PE}s perform
computation on their own subdomains of the larger problem, and periodically 
communicate with other \ac{PE}s to exchange information on which the
next computation phase depends.
%SP: Addressing suggestions from discussion on 01/31/2014
The \openshmem data-transfer functions are one-sided in nature. This means that a local \ac{PE} executing a data-transfer does not require the participation of the remote \ac{PE} to complete the operation. This allows for overlap between communication and computation which hides data-transfer latencies, making \openshmem ideal for applications with unstructured communication patterns.
%Data latency is  the  period  of  time that starts when a \ac{PE} initiates a transfer of data 
%and ends when a \ac{PE} can use the data. %SP: What about put? Not guaranteed till synchronization is hit.

%SP: Addressing suggestions from discussion on 01/28/2014
%\openshmem functions support remote data transfer through \FUNC{put} operations, which  transfer data to a 
%different \ac{PE}, get operations, which transfer data from a different \ac{PE}, and remote pointers, which 
%allow direct  references  to  data objects owned by another \ac{PE}. Other operations supported are \FUNC{collective} 
%\FUNC{broadcast} and \FUNC{reduction}, \FUNC{barrier synchronization}, and \FUNC{atomic memory operations}. 
%An atomic memory operation  is an atomic read-and-update operation, such as a fetch-and-increment, on a remote
%or local data object.

\rcomment{Manju: [The idea is to talk SPMD. We are talking about nature of interfaces rather than 
 the interfaces that enable SPMD. Replace the second paragraph with the one below ?]}

The \openshmem{} interfaces can be used to implement \ac{SPMD} style programs. It provides interfaces 
to start the \openshmem{} processes in parallel, and communication and synchronization interfaces for data and control distribution. These interfaces can be leveraged to divide a problem to into multiple sub-problems that can solved independently or with co-ordination using the communication and synchronization interfaces.

The \openshmem specification defines library calls, constants, variables, and language bindings for \Clang{} and \Fortran{}.
The \Cpp{} interface is currently the same as that for \Clang. An overview of the important \openshmem operations is described below:

\begin{enumerate}
\item \textbf{Data Transfers }

\begin{enumerate}
\item One-sided \FUNC{puts} : the local \ac{PE} specifies the source
data (local or symmetric) to be written to the symmetric target on the remote \ac{PE}. 
\item One-sided \FUNC{gets} : an explicit fetch operation is used to copy a symmetric source variable
from a remote \ac{PE} and store it to a variable on the local \ac{PE}.\end{enumerate}

%\begin{description}
%\item [{{Note:}}] By avoiding the need for matching send and receive
%calls, \openshmem simplifies the communication process by reducing the
%number of calls required to have one \ac{PE} interact with other \ac{PE}s. 
%\end{description}
\item \textbf{Synchronization Mechanisms }
\begin{enumerate}
\item \FUNC{Fence}: Ensures ordering of PUT operations to a specific \ac{PE}. 
\item \FUNC{Quiet}: Ensures ordering of PUT operations to all \ac{PE}s. 
\item \FUNC{Barrier}: A collective synchronization routine in which no \ac{PE} may leave
the barrier prior to all \ac{PE}s entering the barrier. 
\end{enumerate}
\item \textbf{Collective Communication}

\begin{enumerate}
\item \FUNC{Broadcast}: Copy a block of data from one \ac{PE} to one or more remote
PEs. 
\item \FUNC{Collection}: Concatenate elements from the source array to a target
array over the specified \ac{PE}s. 
\item \FUNC{Reduction}: Perform an associative binary operation over the specified
\ac{PE}s. 
\end{enumerate}
\item \textbf{Address Manipulation}

\begin{enumerate}
\item Allocating and deallocating memory blocks in the symmetric space.
\end{enumerate}
\item \textbf{Locks}

\begin{enumerate}
\item Implementation of mutual exclusion.
\end{enumerate}
\item \textbf{Atomic Memory Operations}

\begin{enumerate}
\item Swap, Conditional Swap, Add and Increment 
\end{enumerate}
\item \textbf{Data Cache control}

\begin{enumerate}
\item Implementation of mechanisms to exploit the capabilities of hardware
cache if available.
\end{enumerate}
\end{enumerate}
%\begin{description}
%\item [{{Note:}}] More information about \openshmem routines can be found
%in the Library Routines section.
%\end{description}
